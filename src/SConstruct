# -*- coding: utf-8 -*-

from __future__ import print_function

import os
import os.path
from commands import getstatusoutput
from glob import iglob
from itertools import chain
from multiprocessing import cpu_count
from subprocess import check_output
from sys import exit, argv

LOCAL_INCLUDE_PATHS = [".", "include", "../include"]
LOCAL_COMMON_PATHS = ["common", "../common"]
PATHLIST = os.environ["PATH"].split(os.pathsep)


def exe(fpath):
    """Check if the given path/filename both exists and is executable."""
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def which(program):
    """Check if a program exists in PATH"""
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in PATHLIST:
            exe_file = os.path.join(path, program)
            # Check if the file exists and is executable
            if exe(exe_file):
                return exe_file
    return None


def split_cxxflags(given_cxxflags):
    """Split a list of flags into includes (-I...), defines (-D...), libs (-l...), lib paths (-L...), linkflags (-Wl,) and other flags (-p)"""
    includes = ""
    defines = ""
    libs = ""
    libpaths = ""
    linkflags = ""
    other = ""
    for flag in [f.strip() for f in given_cxxflags.split(" ")]:
        if flag.startswith("-I"):
            includes += flag[2:] + " "
        elif flag.startswith("-D"):
            defines += flag[2:] + " "
        elif flag.startswith("-l"):
            libs += flag[2:] + " "
        elif flag.startswith("-L"):
            libpaths += flag + " "
        elif flag.startswith("-Wl,"):
            linkflags += flag + " "
        elif flag.startswith("-p"):
            other += flag + " "
        else:
            # Only includes, defines, libraries, library paths and linkflags are supported
            print("WARNING: Unsupported flag: " + flag)
            continue
    # Other CXXFLAGS can be returned as the final value here
    return includes.strip(), defines.strip(), libs.strip(), libpaths.strip(), linkflags.strip(), other.strip()


def arch_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For Arch Linux."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = 'LC_ALL=C /usr/bin/pacman -Qo ' + include_path + ' | /usr/bin/cut -d" " -f5'
    package = os.popen2(cmd)[1].read().strip()
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = '/usr/bin/pacman -Ql ' + package + ' | /usr/bin/grep "\.pc$" | /usr/bin/cut -d" " -f2-'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def freebsd_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For FreeBSD."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = '/usr/sbin/pkg which -q ' + include_path + ' | cut -d- -f1'
    package = os.popen2(cmd)[1].read().strip()
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = "/usr/sbin/pkg list " + package + " | /usr/bin/grep '\.pc$'"
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/local/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def ubuntu_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string
    For Debian/Ubuntu."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = 'LC_ALL=C /usr/bin/dpkg-query -S ' + include_path + ' | /usr/bin/cut -d: -f1'
    package = os.popen2(cmd)[1].read().strip()
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = 'LC_ALL=C /usr/bin/dpkg-query -L ' + package + ' | /bin/grep "\.pc$"'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def brew_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For macOS/homebrew."""
    # Follow symlinks
    realpath = os.path.realpath(include_path)
    # If the path now starts with "/usr/local/Cellar/", then success, else return
    if not (realpath.startswith("/usr/local/Cellar/") and realpath.count("/") > 4):
        return ""
    # Strip away "/usr/local/Cellar/" from the start of the path
    package = realpath[18:].split("/")[0]
    # Get all .pc files that belong to the same package
    cmd = 'LC_ALL=C brew ls --verbose ' + package + ' | grep "\.pc$"'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = 'pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def get_buildflags(sourcefilename, system_include_dir):
    """Given a source file, try to extract the relevant includes and get pkg-config to output relevant --cflags and --libs.
    Returns includes, defines, libs, lib paths, linkflags and other cxx flags"""
    try:
        lines = open(sourcefilename).read().split(os.linesep)[:-1]
    except:
        return "", "", "", "", "", ""
    includes = []
    for line in lines:
        if line.strip().startswith("#include"):
            if line.count("<") == 1 and line.count(">") == 1:
                includes.append(line.strip().split("<")[1].split(">")[0])
            elif line.count("\"") == 2:
                includes.append(line.strip().split("\"")[1].split("\"")[0])

    # Skip C99, C++, C++20 and deprecated C++ headers + more
    skiplist = ("assert.h", "complex.h", "ctype.h", "errno.h", "fenv.h", "float.h", "inttypes.h", "iso646.h", "limits.h", "locale.h", "math.h", "setjmp.h", "signal.h", "stdalign.h", "stdarg.h", "stdatomic.h", "stdbool.h", "stddef.h", "stdint.h", "stdio.h", "stdlib.h", "stdnoreturn.h", "string.h", "tgmath.h", "threads.h", "time.h", "uchar.h", "wchar.h", "wctype.h", "cstdlib", "csignal", "csetjmp", "cstdarg", "typeinfo", "typeindex", "type_traits", "bitset", "functional", "utility", "ctime", "chrono", "cstddef", "initializer_list", "tuple", "any", "optional", "variant", "new", "memory", "scoped_allocator", "memory_resource", "climits", "cfloat", "cstdint", "cinttypes", "limits", "exception", "stdexcept", "cassert", "system_error", "cerrno", "array", "vector", "deque", "list", "forward_list", "set", "map", "unordered_set", "unordered_map", "stack", "queue", "algorithm", "execution", "iterator", "cmath", "complex", "valarray", "random", "numeric", "ratio", "cfenv", "iosfwd", "ios", "istream", "ostream", "iostream", "fstream", "sstream", "iomanip", "streambuf", "cstdio", "locale", "clocale", "regex", "atomic", "thread", "mutex", "shared_mutex", "future", "condition_variable", "filesystem", "compare", "charconv", "syncstream", "strstream", "codecvt", "glibc")

    # Filter out skipped includes, and includes in LOCAL_INCLUDE_PATHS
    filtered_includes = []
    for include in includes:
        if include in skiplist:
            continue
        found = False
        for local_include_path in LOCAL_INCLUDE_PATHS:
            if os.path.exists(os.path.join(local_include_path, include)):
                found = True
                break
        if not found:
            filtered_includes.append(include)
    includes = filtered_includes

    # Check for installed frameworks in /Library/Frameworks
    if os.path.exists("/Library/Frameworks"):
        # on macOS, prefer not to use pkg-config
        for include in includes:
            first_word = include
            if "/" in include:
                first_word = include.split("/")[0].lower()
            if os.path.exists("/Library/Frameworks/" + first_word + ".framework"):
                # Found it!
                framework_flags = "-F/Library/Frameworks -framework " + first_word
                return "", "", "", "", framework_flags, framework_flags

    # Nothing more to do if pkg-config is missing
    if not which("pkg-config"):
        print("NOTE: pkg-config must be installed for library-detection to work")
        return "", "", "", "", "", ""

    # If the include exists in /usr/include, what is the first word, in lowercase?
    for include in includes:
        if os.path.exists(os.path.join(system_include_dir, include)):
            first_word = include.lower()
            if "/" in include:
                first_word = include.split("/")[0].lower()
            cmd = "pkg-config --cflags --libs " + first_word + " 2>/dev/null"
            all_cxxflags = os.popen2(cmd)[1].read().strip()
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)

    # Using the include_lines, find the correct CFLAGS on Debian/Ubuntu
    if exe("/usr/bin/dpkg-query"):
        for include in includes:
            include_path = os.path.join(system_include_dir, include)
            all_cxxflags = ubuntu_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)
        # Try the same with dpkg-query, but now using find to search deeper in system_include_dir
        for include in includes:
            # Search system_include_dir
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            all_cxxflags = ubuntu_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)

    # Using the include_lines, find the correct CFLAGS on Arch Linux
    if exe("/usr/bin/pacman"):
        for include in includes:
            include_path = os.path.join(system_include_dir, include)
            all_cxxflags = arch_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)
        # Try the same with pacman, but now using find to search deeper in /usr/include
        for include in includes:
            # Search /usr/include
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            all_cxxflags = arch_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)

    # Using the include_lines, find the correct CFLAGS on FreeBSD
    if exe("/usr/sbin/pkg"):
        for include in includes:
            include_path = os.path.join(system_include_dir, include)
            all_cxxflags = freebsd_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)
        # Try the same, but now using find to search deeper in system_include_dir
        for include in includes:
            # Search system_include_dir
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            all_cxxflags = freebsd_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)

    # Using the include_lines, find the correct CFLAGS on macOS with Homebrew and pkg-config installed
    if which("brew"):
        for include in includes:
            # Homebrew does not support finding the package that owns a file, search /usr/local/include instead
            cmd = 'find -s -L ' + system_include_dir + ' -type f -wholename "*' + include + '" | tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            all_cxxflags = brew_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)

    # CFLAGS, defines and libs not found
    return "", "", "", "", "", ""


def get_main_source_file(test_sources=None):
    """Get the main source file. It may be named main.cpp or main.cc, or be the only one, or the one containing 'main('.
    Return a blank string if none is found."""
    if os.path.exists("main.cpp"):
        return "main.cpp"
    if os.path.exists("main.cc"):
        return "main.cc"
    if os.path.exists("main.cxx"):
        return "main.cc"
    # No main source file, see if there is only one non-test source file there
    if not test_sources:
        test_sources = get_test_sources()
    all_sources = [fname for fname in chain(iglob("*.cpp"), iglob("*.cc"), iglob("*.cxx")) if fname not in test_sources]
    if len(all_sources) == 0:
        # No main source
        return ""
    if len(all_sources) == 1:
        # Return the 1 source file that was found
        return all_sources[0]
    # Multiple candidates for the main source file, use the one that contains the word "main("
    for fname in all_sources:
        if "main(" in open(fname).read():
            return fname
    # No source file contained "main(", there may not be a main source file here
    return ""


def get_test_sources():
    """Get all source files ending with _test.cpp, _test.cc, _test.cxx or named test.cpp, test.cc or test.cxx"""
    test_sources = chain(iglob("*_test.cpp"), iglob("*_test.cc"), iglob("*_test.cxx"))
    if os.path.exists("test.cc"):
        test_sources.append("test.cc")
    elif os.path.exists("test.cpp"):
        test_sources.append("test.cpp")
    elif os.path.exists("test.cxx"):
        test_sources.append("test.cxx")
    return list(test_sources)


def get_dep_sources(main_source_file=None, test_sources=None):
    """Get all source files that the main executable, or test executables, may depend upon"""
    if not test_sources:
        test_sources = get_test_sources()
    if not main_source_file:
        main_source_file = get_main_source_file(test_sources)
    return [fname for fname in chain(iglob("*.cpp"), iglob("*.cc"), iglob("*.cxx")) if (fname != main_source_file) and (fname not in test_sources)]


def strip_ext(filenames):
    """Remove filename extensions from the list of filenames"""
    return [os.path.splitext(fname)[0] for fname in filenames]

# ---


# Test ELF-files to be generated. Don't add "test" here since it may be passed back to this file as an argument!
test_sources = get_test_sources()

# Main ELF-file to be generated
main_source_file = get_main_source_file(test_sources)

# Find all source files that are not the main source file and not test files
dep_src = get_dep_sources(main_source_file, test_sources)

# Test executables to be built
test_elves = []
if test_sources:
    test_elves = strip_ext(test_sources)

# Main executable to be built
main_elf = ""
if main_source_file:
    main_elf = os.path.splitext(main_source_file)[0]


# Custom command line targets
if 'clean' in COMMAND_LINE_TARGETS:  # Clean built executables and object files
    # Replace the "clean" argument with "-c", and list all targets
    cmd = [x for x in argv if x != "clean"] + ["-c"] + [main_elf] + test_elves
    # Clean
    status, output = getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    exit(status)
elif 'testbuild' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in argv if x != "testbuild"] + test_elves
    # Build the tests
    status, output = getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    exit(status)
elif 'test' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in argv if x != "test"] + test_elves
    # Build the tests
    output = check_output(cmd)
    output = os.linesep.join([line for line in output.split(
        os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run the tests
    for test_elf in test_elves:
        status, output = getstatusoutput(os.path.join(".", test_elf))
        output = output.strip()
        if output:
            print(output)
        # Exit on error
        if status != 0:
            exit(status)
    exit(0)
elif 'run' in COMMAND_LINE_TARGETS:  # Build and run main
    # Remove the "run" argument, and add "main"
    cmd = [x for x in argv if x != "run"] + [main_elf]
    # Check if any main source file exists
    if not main_source_file:
        print("Nothing to run (no main.cpp)")
        exit(0)
    # Build main
    output = check_output(cmd)
    output = os.linesep.join([line for line in output.split(
        os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run the first main elf
    status, output = getstatusoutput(os.path.join(".", main_elf))
    output = output.strip()
    if output:
        print(output)
    exit(status)

# Set the number of jobs to the number of CPUs
SetOption('num_jobs', cpu_count())

# Random build-order, for the possiblity of using the cache better
SetOption('random', 1)

# Create an environment
env = Environment()

# Use the given CXX as the default value for the C++ compiler
if 'CXX' in ARGUMENTS:
    env.Replace(CXX=ARGUMENTS['CXX'])

# std is not set, use the latest C++ standard
if not ARGUMENTS.get('std', ''):
    # Use C++17
    env.Append(CXXFLAGS=' -std=c++17')
else:
    # if std is something else, use that
    args = []
    for key, value in ARGLIST:
        if key == 'std':
            env.Append(CXXFLAGS=' -std=' + value)

system_include_dir = "/usr/include"
# Set system_include_dir to the given value, or keep it as /usr/include
if ARGUMENTS.get('system_include_dir', ''):
    system_include_dir = ARGUMENTS['system_include_dir']
#print("SYSTEM_INCLUDE_DIR = " + system_include_dir)

# debug is set?
if int(ARGUMENTS.get('debug', 0)):
    env.Append(CXXFLAGS=' -Og -g -fno-omit-frame-pointer -fsanitize=address')
    env.Append(LINKFLAGS=' -fsanitize=address')
# small is set?
elif int(ARGUMENTS.get('small', 0)):
    env.Append(CXXFLAGS=' -Os -ffunction-sections -fdata-sections')
    env.Append(LINKFLAGS=' -ffunction-sections -fdata-sections -Wl,-s -Wl,-gc-sections')
# opt is set?
elif int(ARGUMENTS.get('opt', 0)):
    env.Append(CXXFLAGS=' -O3')
# default optimization level
else:
    env.Append(CXXFLAGS=' -O2')

# Check if a particular C++ compiler is given, or not
if env["CXX"] == "c++":
    # Use the HEAD version of GCC as installed with Homebrew, if available
    if which("g++-HEAD"):
        env.Replace(CXX="g++-HEAD")
    else:
        env.Replace(CXX="g++")
    # clang is set?
    if int(ARGUMENTS.get('clang', 0)):
        env.Replace(CXX='clang++')

# if sloppy is set, just try to build the damn thing
if int(ARGUMENTS.get('sloppy', 0)):
    env.Append(CXXFLAGS=' -fpermissive -w')
else:
    # if sloppy is not set, add various warnings:

    # pretty strict + fail at first error
    env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wfatal-errors')

    # if strict is set, enable even more warnings
    if int(ARGUMENTS.get('strict', 0)):
        env.Append(CXXFLAGS=' -Wextra -Wconversion -Weffc++')

# Append any given CXXFLAGS after the other flags, to be able to override them
if 'CXXFLAGS' in ARGUMENTS:
    env.Append(CXXFLAGS=ARGUMENTS['CXXFLAGS'])

# add path to the include files
env.Append(CPPPATH=LOCAL_INCLUDE_PATHS)

# Find all included header files in ../include, then check if there are corresponding
# sourcefiles in ../common and add them to dep_src, if there is a main source file
if os.path.exists(main_source_file):
    includes = []
    has_new_include = True
    examined = []
    while has_new_include:
        has_new_include = False
        for INCLUDE_PATH in LOCAL_INCLUDE_PATHS:
            for filename in dep_src + [main_source_file] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
                if filename in examined:
                    continue
                examined.append(filename)
                if os.path.exists(filename):
                    new_includes = [line.split("\"")[1] for line in open(filename).read().split(
                        os.linesep)[:-1] if line.strip().startswith("#include \"")]
                else:
                    continue
                for new_include in [os.path.relpath(x) for x in new_includes]:
                    if new_include not in includes:
                        has_new_include = True
                        includes.append(new_include)
            for include in includes:
                for COMMON_PATH in LOCAL_COMMON_PATHS:
                    for ext in [".cpp", ".cc", ".cxx"]:
                        source_filename = os.path.join(COMMON_PATH, include.rsplit(".", 1)[0] + ext)
                        if os.path.exists(source_filename):
                            if source_filename not in dep_src:
                                dep_src.append(source_filename)

# Find extra CFLAGS for the sources, if not cleaning
if not (env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS):
    for src_file in [main_source_file] + dep_src:
        includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(src_file, system_include_dir)
        if includes:
            for include in includes.split(" "):
                env.Append(CPPPATH=include)
        if defines:
            for define in defines.split(" "):
                env.Append(CPPDEFINES=define)
        if libs:
            env.Append(LIBS=libs.split(" "))
        if libpaths:
            env.Append(LINKFLAGS=libpaths)
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if other_cxxflags:
            env.Append(CXXFLAGS=other_cxxflags)

# Build main executable
if main_source_file:
    main = env.Program(main_elf, [main_source_file] + dep_src)

# Find extra CFLAGS for the test sources, if not cleaning
if not (env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS):
    for src_file in test_sources:
        includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(src_file, system_include_dir)
        if includes:
            for include in includes.split(" "):
                env.Append(CPPPATH=include)
        if defines:
            for define in defines.split(" "):
                env.Append(CPPDEFINES=define)
        if libs:
            env.Append(LIBS=libs.split(" "))
        if libpaths:
            env.Append(LINKFLAGS=libpaths)
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if other_cxxflags:
            env.Append(CXXFLAGS=other_cxxflags)

# Remove non-existing includes
includes = [include for include in env['CPPPATH'] if os.path.exists(include)]
# Remove duplicate includes (in terms of pointing to the same directory)
includemap = {}
for include in includes:
    key = os.path.normpath(include)
    if key in includemap:
        # use the shortest includepath, if several are specified for the same directory
        if len(include) < len(includemap[key]):
            if len(os.path.relpath(include)) < len(include):
                includemap[key] = os.path.relpath(include)
            else:
                includemap[key] = include
    else:
        if len(os.path.relpath(include)) < len(include):
            includemap[key] = os.path.relpath(include)
        else:
            includemap[key] = include
new_includes = includemap.values()
env.Append(CPPFLAGS=" ".join(["-I" + x for x in new_includes]))
env.Replace(CPPPATH=[])
# This also work for adding includes, but SConstruct changes them to longer versions of the same path names
# env.Replace(CPPPATH=new_includes)

# Set up non-default targets for all the test executables (based on *_test sources)
for test_src in test_sources:
    test_elf = os.path.splitext(test_src)[0]
    env.Program(test_elf, [test_src] + dep_src)

# Only main is the default target
Default(main)

# vim: ts=4 sw=4 et:
