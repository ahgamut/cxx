# -*- coding: utf-8 -*-

from __future__ import print_function

import os
import os.path
from commands import getstatusoutput
from glob import iglob
from itertools import chain
from multiprocessing import cpu_count
from subprocess import check_output
from sys import exit, argv

LOCAL_INCLUDE_PATHS = [".", "include", "../include"]
LOCAL_COMMON_PATHS = ["common", "../common"]
PATHLIST = os.environ["PATH"].split(os.pathsep)


def exe(fpath):
    """Check if the given path/filename both exists and is executable."""
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def which(program):
    """Check if a program exists in PATH"""
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in PATHLIST:
            exe_file = os.path.join(path, program)
            # Check if the file exists and is executable
            if exe(exe_file):
                return exe_file
    return None


def split_cxxflags(given_cxxflags):
    """Split a list of flags into includes (-I...), defines (-D...), libs (-l...), lib paths (-L...), linkflags (-Wl,) and other flags (-p, -F, -framework)"""
    includes = ""
    defines = ""
    libs = ""
    libpaths = ""
    linkflags = ""
    other = ""
    # Note that -Wl,-framework may appear in the given_cxxflags
    for flag in [f.strip() for f in given_cxxflags.replace(" -framework ", " -framework!").split(" ")]:
        if flag.startswith("-I"):
            includes += flag[2:] + " "
        elif flag.startswith("-D"):
            defines += flag[2:] + " "
        elif flag.startswith("-l"):
            libs += flag[2:] + " "
        elif flag.startswith("-L"):
            libpaths += flag + " "
        elif flag.startswith("-Wl,"):
            linkflags += flag + " "
        elif flag.startswith("-p"):
            other += flag + " "
        elif flag.lower().startswith("-f"):
            new_flag = flag.replace("-framework!", "-framework ")
            if new_flag not in linkflags:
                linkflags += new_flag + " "
        elif flag.startswith("-stdlib"):
            if not flag in linkflags:
                linkflags += flag + " "
            if not flag in other:
                other += flag + " "
        else:
            # Only includes, defines, libraries, library paths and linkflags are supported
            print("WARNING: Unsupported flag: " + flag)
            continue
    # Other CXXFLAGS can be returned as the final value here
    return includes.strip(), defines.strip(), libs.strip(), libpaths.strip(), linkflags.strip(), other.strip()


def arch_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For Arch Linux."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = 'LC_ALL=C /usr/bin/pacman -Qo ' + include_path + ' | /usr/bin/cut -d" " -f5'
    package = os.popen2(cmd)[1].read().strip()
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = '/usr/bin/pacman -Ql ' + package + ' | /usr/bin/grep "\.pc$" | /usr/bin/cut -d" " -f2-'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def freebsd_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For FreeBSD."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = '/usr/sbin/pkg which -q ' + include_path + ' | cut -d- -f1'
    package = os.popen2(cmd)[1].read().strip()
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = "/usr/sbin/pkg list " + package + " | /usr/bin/grep '\.pc$'"
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/local/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def ubuntu_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string
    For Debian/Ubuntu."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = 'LC_ALL=C /usr/bin/dpkg-query -S ' + include_path + ' | /usr/bin/cut -d: -f1'
    package = os.popen2(cmd)[1].read().strip()
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = 'LC_ALL=C /usr/bin/dpkg-query -L ' + package + ' | /bin/grep "\.pc$"'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def brew_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For macOS/homebrew."""
    # Follow symlinks
    realpath = os.path.realpath(include_path)
    # If the path now starts with "/usr/local/Cellar/", then success, else return
    if not (realpath.startswith("/usr/local/Cellar/") and realpath.count("/") > 4):
        return ""
    # Strip away "/usr/local/Cellar/" from the start of the path
    package = realpath[18:].split("/")[0]
    # Get all .pc files that belong to the same package
    cmd = 'LC_ALL=C brew ls --verbose ' + package + ' | grep "\.pc$"'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = 'pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def get_buildflags(sourcefilename, system_include_dir):
    """Given a source file, try to extract the relevant includes and get pkg-config to output relevant --cflags and --libs.
    Returns includes, defines, libs, lib paths, linkflags and other cxx flags"""
    try:
        lines = open(sourcefilename).read().split(os.linesep)[:-1]
    except:
        return "", "", "", "", "", ""
    includes = []
    for line in lines:
        if line.strip().startswith("#include"):
            if line.count("<") == 1 and line.count(">") == 1:
                includes.append(line.strip().split("<")[1].split(">")[0])
            elif line.count("\"") == 2:
                includes.append(line.strip().split("\"")[1].split("\"")[0])

    # Skip C99, C++, C++20 and deprecated C++ headers + more
    skiplist = ("assert.h", "complex.h", "ctype.h", "errno.h", "fenv.h", "float.h", "inttypes.h", "iso646.h", "limits.h", "locale.h", "math.h", "setjmp.h", "signal.h", "stdalign.h", "stdarg.h", "stdatomic.h", "stdbool.h", "stddef.h", "stdint.h", "stdio.h", "stdlib.h", "stdnoreturn.h", "string.h", "tgmath.h", "threads.h", "time.h", "uchar.h", "wchar.h", "wctype.h", "cstdlib", "csignal", "csetjmp", "cstdarg", "typeinfo", "typeindex", "type_traits", "bitset", "functional", "utility", "ctime", "chrono", "cstddef", "initializer_list", "tuple", "any", "optional", "variant", "new", "memory", "scoped_allocator", "memory_resource", "climits",
                "cfloat", "cstdint", "cinttypes", "limits", "exception", "stdexcept", "cassert", "system_error", "cerrno", "array", "vector", "deque", "list", "forward_list", "set", "map", "unordered_set", "unordered_map", "stack", "queue", "algorithm", "execution", "iterator", "cmath", "complex", "valarray", "random", "numeric", "ratio", "cfenv", "iosfwd", "ios", "istream", "ostream", "iostream", "fstream", "sstream", "iomanip", "streambuf", "cstdio", "locale", "clocale", "regex", "atomic", "thread", "mutex", "shared_mutex", "future", "condition_variable", "filesystem", "compare", "charconv", "syncstream", "strstream", "codecvt", "glibc")

    # Filter out skipped includes, and includes in LOCAL_INCLUDE_PATHS
    filtered_includes = []
    for include in includes:
        if include in skiplist:
            continue
        found = False
        for local_include_path in LOCAL_INCLUDE_PATHS:
            if os.path.exists(os.path.join(local_include_path, include)):
                found = True
                break
        if not found:
            filtered_includes.append(include)
    includes = filtered_includes

    flag_dict = {}  # Map include files to flags

    # Check for installed frameworks in /Library/Frameworks
    if os.path.exists("/Library/Frameworks"):
        # on macOS, prefer not to use pkg-config
        for include in includes:
            first_word = include
            if "/" in include:
                first_word = include.split("/")[0].strip().lower()
            if os.path.exists("/Library/Frameworks/" + first_word + ".framework"):
                # Found it!
                new_flags = "-I/usr/local/include -F/Library/Frameworks -framework " + first_word
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags

    # Nothing more to do if pkg-config is missing
    has_pkg_config = bool(which("pkg-config"))
    if not has_pkg_config and not flag_dict.keys():
        print("NOTE: pkg-config must be installed for library-detection to work")

    # If the include exists in /usr/include, what is the first word, in lowercase?
    for include in includes:
        if include in flag_dict:
            continue
        if os.path.exists(os.path.join(system_include_dir, include)):
            # Add the include directory as an -I flag if the include file was found
            if include in flag_dict:
                flag_dict["GLOBAL"] += " -I" + system_include_dir
            else:
                flag_dict["GLOBAL"] = "-I" + system_include_dir
            # If pkg-config exists, add additional flags
            if has_pkg_config:
                # Add flags from pkg-config, if available for the first word of the include
                first_word = include.lower()
                if "/" in include:
                    first_word = include.split("/")[0].lower()
                cmd = "pkg-config --cflags --libs " + first_word + " 2>/dev/null"
                new_flags = os.popen2(cmd)[1].read().strip()
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags

    # Using the include_lines, find the correct CFLAGS on Debian/Ubuntu
    if has_pkg_config and exe("/usr/bin/dpkg-query"):
        for include in includes:
            if include in flag_dict:
                continue
            include_path = os.path.join(system_include_dir, include)
            new_flags = ubuntu_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
        # Try the same with dpkg-query, but now using find to search deeper in system_include_dir
        for include in includes:
            if include in flag_dict:
                continue
            # Search system_include_dir
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = ubuntu_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Using the include_lines, find the correct CFLAGS on Arch Linux
    if has_pkg_config and exe("/usr/bin/pacman"):
        for include in includes:
            if include in flag_dict:
                continue
            include_path = os.path.join(system_include_dir, include)
            new_flags = arch_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
        # Try the same with pacman, but now using find to search deeper in /usr/include
        for include in includes:
            if include in flag_dict:
                continue
            # Search /usr/include
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = arch_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Using the include_lines, find the correct CFLAGS on FreeBSD
    if has_pkg_config and exe("/usr/sbin/pkg"):
        for include in includes:
            if include in flag_dict:
                continue
            include_path = os.path.join(system_include_dir, include)
            new_flags = freebsd_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
        # Try the same, but now using find to search deeper in system_include_dir
        for include in includes:
            if include in flag_dict:
                continue
            # Search system_include_dir
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = freebsd_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Using the include_lines, find the correct CFLAGS on macOS with Homebrew and pkg-config installed
    if has_pkg_config and which("brew"):
        for include in includes:
            if include in flag_dict:
                continue
            # Homebrew does not support finding the package that owns a file, search /usr/local/include instead
            cmd = 'find -s -L ' + system_include_dir + ' -type f -wholename "*' + include + '" | tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = brew_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Special cases - additional build flags that should be reported as bugs and added to the ".pc" files that comes with libraries.
    # This must come last
    for include in includes:
        # SFML on macOS
        if include.split("/")[0].strip().lower() == "sfml":
            new_flags = ""
            # Check if the macOS Frameworks path exists
            if os.path.exists("/Library/Frameworks"):
                # Found it, add the OpenGL framework as well
                new_flags = "-I/usr/local/include -F/Library/Frameworks -framework OpenGL"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
                # if clang is set, add "-stdlib=libc++" when using SFML, on macOS
                if int(ARGUMENTS.get('clang', 0)):
                    if include in flag_dict:
                        flag_dict[include] += " -stdlib=libc++"
                    else:
                        flag_dict[include] = " -stdlib=libc++"
            if has_pkg_config:
                # Try pkg-config
                cmd = "pkg-config --cflags --libs gl 2>/dev/null"
                new_flags = os.popen2(cmd)[1].read().strip()
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags

    # Collect and return all the flags in flag_dict
    all_cxxflags = " ".join(flag_dict.values())

    all_cxxflags_stripped = all_cxxflags.strip()
    if all_cxxflags_stripped:
        return split_cxxflags(all_cxxflags_stripped)

    # CFLAGS, defines and libs not found
    return "", "", "", "", "", ""


def get_main_source_file(test_sources=None):
    """Get the main source file. It may be named main.cpp or main.cc, or be the only one, or the one containing 'main('.
    Return a blank string if none is found."""
    for ext in ["cpp", "cc", "cxx"]:
        if os.path.exists("main." + ext):
            return "main." + ext
    # No main source file, see if there is only one non-test source file there
    if not test_sources:
        test_sources = get_test_sources()
    all_sources = [fname for fname in chain(
        iglob("*.cpp"), iglob("*.cc"), iglob("*.cxx")) if fname not in test_sources]
    if len(all_sources) == 0:
        # No main source
        return ""
    if len(all_sources) == 1:
        # Return the 1 source file that was found
        return all_sources[0]
    # Multiple candidates for the main source file, use the one that contains the word "main("
    for fname in all_sources:
        if "main(" in open(fname).read():
            return fname
    # No source file contained "main(", there may not be a main source file here
    return ""


def get_test_sources():
    """Get all source files ending with _test.cpp, _test.cc, _test.cxx or named test.cpp, test.cc or test.cxx"""
    test_sources = list(chain(iglob("*_test.cpp"), iglob("*_test.cc"), iglob("*_test.cxx")))
    if os.path.exists("test.cc"):
        test_sources.append("test.cc")
    elif os.path.exists("test.cpp"):
        test_sources.append("test.cpp")
    elif os.path.exists("test.cxx"):
        test_sources.append("test.cxx")
    return test_sources


def get_dep_sources(main_source_file=None, test_sources=None):
    """Get all source files that the main executable, or test executables, may depend upon"""
    if not test_sources:
        test_sources = get_test_sources()
    if not main_source_file:
        main_source_file = get_main_source_file(test_sources)
    return [fname for fname in chain(iglob("*.cpp"), iglob("*.cc"), iglob("*.cxx")) if (fname != main_source_file) and (fname not in test_sources)]


def strip_ext(filenames):
    """Remove filename extensions from the list of filenames"""
    return [os.path.splitext(fname)[0] for fname in filenames]


def signal_handler(signal, frame):
    """ctrl-c handler"""
    print('Canceled')
    exit(1)


def sakemake():
    """The main function"""

    # Test ELF-files to be generated. Don't add "test" here since it may be passed back to this file as an argument!
    test_sources = get_test_sources()

    # Main ELF-file to be generated
    main_source_file = get_main_source_file(test_sources)

    # Find all source files that are not the main source file and not test files
    dep_src = get_dep_sources(main_source_file, test_sources)

    # Test executables to be built
    test_elves = []
    if test_sources:
        test_elves = strip_ext(test_sources)

    # Main executable to be built
    main_elf = ""
    if main_source_file:
        main_elf = os.path.splitext(main_source_file)[0]

    # Custom command line targets
    if 'clean' in COMMAND_LINE_TARGETS:  # Clean built executables and object files
        if (not test_elves) and (not main_elf):
            print("Nothing to clean")
            exit(0)
        # Replace the "clean" argument with "-c", and list all targets
        cmd = [x for x in argv if x != "clean"] + ["-c"] + [main_elf] + test_elves
        # Clean
        status, output = getstatusoutput(" ".join(cmd))
        output = output.strip()
        if output:
            print(output)
        exit(status)
    elif 'testbuild' in COMMAND_LINE_TARGETS:  # Build and run tests
        if not test_elves:
            print("No tests to build")
            exit(0)
        # Remove the "test" argument, and list all test-executable targets
        cmd = [x for x in argv if x != "testbuild"] + \
            [elf for elf in test_elves if elf != "testbuild"]
        # Build the tests
        status, output = getstatusoutput(" ".join(cmd))
        output = output.strip()
        if output:
            print(output)
        exit(status)
    elif 'test' in COMMAND_LINE_TARGETS:  # Build and run tests
        if not test_elves:
            print("Nothing to test")
            exit(0)
        # Remove the "test" argument, and list all test-executable targets
        cmd = [x for x in argv if x != "test"] + [elf for elf in test_elves if elf != "test"]
        # Build the tests
        try:
            output = check_output(cmd)
        except CalledProcessError:
            print("Could not run: " + cmd)
            exit(1)
        output = os.linesep.join([line for line in output.split(
            os.linesep) if not "up to date" in line]).strip()
        if output:
            print(output)
        # Run the tests
        for test_elf in test_elves:
            status, output = getstatusoutput(os.path.join(".", test_elf))
            output = output.strip()
            if output:
                print(output)
            # Exit on error
            if status != 0:
                exit(status)
        exit(0)
    elif 'run' in COMMAND_LINE_TARGETS:  # Build and run main
        # Remove the "run" argument, and add "main"
        cmd = [x for x in argv if x != "run"] + [main_elf]
        # Check if any main source file exists
        if not main_source_file:
            print("Nothing to run (no main.cpp)")
            exit(0)
        # Build main
        try:
            output = check_output(cmd)
        except CalledProcessError:
            print("Could not run: " + cmd)
            exit(1)
        output = os.linesep.join([line for line in output.split(
            os.linesep) if not "up to date" in line]).strip()
        if output:
            print(output)
        # Run the first main elf
        status, output = getstatusoutput(os.path.join(".", main_elf))
        output = output.strip()
        if output:
            print(output)
        exit(status)

    # Set the number of jobs to the number of CPUs
    SetOption('num_jobs', cpu_count())

    # Random build-order, for the possiblity of using the cache better
    SetOption('random', 1)

    # Create an environment
    env = Environment()

    # Use the given CXX as the default value for the C++ compiler
    if 'CXX' in ARGUMENTS:
        env.Replace(CXX=ARGUMENTS['CXX'])

    # std is not set, use the latest C++ standard
    if not ARGUMENTS.get('std', ''):
        # Use C++17
        env.Append(CXXFLAGS=' -std=c++17')
    else:
        # if std is something else, use that
        args = []
        for key, value in ARGLIST:
            if key == 'std':
                env.Append(CXXFLAGS=' -std=' + value)

    system_include_dir = "/usr/include"
    # Set system_include_dir to the given value, or keep it as /usr/include
    if ARGUMENTS.get('system_include_dir', ''):
        system_include_dir = ARGUMENTS['system_include_dir']

    # debug is set?
    if int(ARGUMENTS.get('debug', 0)):
        env.Append(CXXFLAGS=' -Og -g -fno-omit-frame-pointer -fsanitize=address')
        env.Append(LINKFLAGS=' -fsanitize=address')
    # small is set?
    elif int(ARGUMENTS.get('small', 0)):
        env.Append(CXXFLAGS=' -Os -ffunction-sections -fdata-sections')
        env.Append(LINKFLAGS=' -ffunction-sections -fdata-sections -Wl,-s -Wl,-gc-sections')
    # opt is set?
    elif int(ARGUMENTS.get('opt', 0)):
        env.Append(CXXFLAGS=' -O3')
    # default optimization level
    else:
        env.Append(CXXFLAGS=' -O2')

    # Check if a particular C++ compiler is given, or not
    if env["CXX"] == "c++":
        # Use the HEAD version of GCC as installed with Homebrew, if available
        if which("g++-HEAD"):
            env.Replace(CXX="g++-HEAD")
        else:
            env.Replace(CXX="g++")
        # clang is set?
        if int(ARGUMENTS.get('clang', 0)):
            env.Replace(CXX='clang++')

    # if sloppy is set, just try to build the damn thing
    if int(ARGUMENTS.get('sloppy', 0)):
        env.Append(CXXFLAGS=' -fpermissive -w')
    else:
        # if sloppy is not set, add various warnings:

        # pretty strict + fail at first error
        env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wno-parentheses -Wfatal-errors')

        # if strict is set, enable even more warnings
        if int(ARGUMENTS.get('strict', 0)):
            env.Append(CXXFLAGS=' -Wextra -Wconversion -Wparentheses -Weffc++')

    # Append any given CXXFLAGS after the other flags, to be able to override them
    if 'CXXFLAGS' in ARGUMENTS:
        env.Append(CXXFLAGS=ARGUMENTS['CXXFLAGS'])

    # add path to the include files
    env.Append(CPPPATH=LOCAL_INCLUDE_PATHS)

    # Find all included header files in ../include, then check if there are corresponding
    # sourcefiles in ../common and add them to dep_src, if there is a main source file
    if os.path.exists(main_source_file):
        includes = []
        has_new_include = True
        examined = []
        while has_new_include:
            has_new_include = False
            for INCLUDE_PATH in LOCAL_INCLUDE_PATHS:
                for filename in dep_src + [main_source_file] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
                    if filename in examined:
                        continue
                    examined.append(filename)
                    if os.path.exists(filename):
                        new_includes = [line.split("\"")[1] for line in open(filename).read().split(
                            os.linesep)[:-1] if line.strip().startswith("#include \"")]
                    else:
                        continue
                    for new_include in [os.path.relpath(x) for x in new_includes]:
                        if new_include not in includes:
                            has_new_include = True
                            includes.append(new_include)
                for include in includes:
                    for COMMON_PATH in LOCAL_COMMON_PATHS:
                        for ext in [".cpp", ".cc", ".cxx"]:
                            source_filename = os.path.join(
                                COMMON_PATH, include.rsplit(".", 1)[0] + ext)
                            if os.path.exists(source_filename):
                                if source_filename not in dep_src:
                                    dep_src.append(source_filename)

    # Find extra CFLAGS for the sources, if not cleaning
    if not (env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS):
        for src_file in [main_source_file] + dep_src:
            includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(
                src_file, system_include_dir)
            if includes:
                for include in includes.split(" "):
                    env.Append(CPPPATH=include)
            if defines:
                for define in defines.split(" "):
                    env.Append(CPPDEFINES=define)
            if libs:
                env.Append(LIBS=libs.split(" "))
            if libpaths:
                env.Append(LINKFLAGS=libpaths)
            if linkflags:
                env.Append(LINKFLAGS=linkflags)
            if other_cxxflags:
                env.Append(CXXFLAGS=other_cxxflags)

    # Build main executable
    if main_source_file:
        main = env.Program(main_elf, [main_source_file] + dep_src)

    # Find extra CFLAGS for the test sources, if not cleaning
    if not (env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS):
        for src_file in test_sources:
            includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(
                src_file, system_include_dir)
            if includes:
                for include in includes.split(" "):
                    env.Append(CPPPATH=include)
            if defines:
                for define in defines.split(" "):
                    env.Append(CPPDEFINES=define)
            if libs:
                env.Append(LIBS=libs.split(" "))
            if libpaths:
                env.Append(LINKFLAGS=libpaths)
            if linkflags:
                env.Append(LINKFLAGS=linkflags)
            if other_cxxflags:
                env.Append(CXXFLAGS=other_cxxflags)

    # Remove non-existing includes
    includes = [include for include in env['CPPPATH'] if os.path.exists(include)]
    # Remove duplicate includes (in terms of pointing to the same directory)
    includemap = {}
    for include in includes:
        key = os.path.normpath(include)
        if key in includemap:
            # use the shortest includepath, if several are specified for the same directory
            if len(include) < len(includemap[key]):
                if len(os.path.relpath(include)) < len(include):
                    includemap[key] = os.path.relpath(include)
                else:
                    includemap[key] = include
        else:
            if len(os.path.relpath(include)) < len(include):
                includemap[key] = os.path.relpath(include)
            else:
                includemap[key] = include
    new_includes = includemap.values()
    env.Append(CPPFLAGS=" ".join(["-I" + x for x in new_includes]))
    env.Replace(CPPPATH=[])
    # This also work for adding includes, but SConstruct changes them to longer versions of the same path names
    # env.Replace(CPPPATH=new_includes)

    # Set up non-default targets for all the test executables (based on *_test sources)
    for test_src in test_sources:
        test_elf = os.path.splitext(test_src)[0]
        env.Program(test_elf, [test_src] + dep_src)

    # Only main is the default target
    try:
        Default(main)
    except UnboundLocalError:
        if env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS:
            print("Nothing to clean")
        elif env.GetOption('test') or 'test' in COMMAND_LINE_TARGETS:
            print("Nothing to test")
        else:
            print("Nothing to build")


# try:
sakemake()
# except KeyboardInterrupt:
#    print("Canceled")
#    exit(1)

# vim: ts=4 sw=4 et:
