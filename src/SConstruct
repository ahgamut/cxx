# -*- coding: utf-8 -*-

from __future__ import print_function

import os
import os.path
from commands import getstatusoutput
from glob import iglob
from itertools import chain
from multiprocessing import cpu_count
from subprocess import check_output
from sys import argv, exit, stdout

LOCAL_INCLUDE_PATHS = [".", "include", "..", "../include"]
LOCAL_COMMON_PATHS = ["common", "../common"]
PATHLIST = os.environ["PATH"].split(os.pathsep)
SPECIAL_SYMBOLS = "@@@@@" # string that is unlikely to appear in an include line or a build flag
SKIP_PACKAGES = ["glibc", "gcc", "wine"] # skip compilation-related packages when searching for includes

def hints(missing_includes):
    """Output hints for how to configure missing includes on some platforms"""
    if "GL/glut.h" in missing_includes:
        print("""
NOTE: On macOS, include GLUT/glut.h instead of GL/glut.h.

Suggested code:

    #ifdef __APPLE__
    #include <GLUT/glut.h>
    #else
    #include <GL/glut.h>
    #endif
""")
    if "GL/gl.h" in missing_includes:
        print("""
NOTE: On macOS, include OpenGL/gl.h instead of GL/gl.h.

Suggested code:

    #ifdef __APPLE__
    #include <OpenGL/gl.h>
    #else
    #include <GL/gl.h>
    #endif
""")


def exe(fpath):
    """Check if the given path/filename both exists and is executable."""
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def which(program):
    """Check if a program exists in PATH"""
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in PATHLIST:
            exe_file = os.path.join(path, program)
            # Check if the file exists and is executable
            if exe(exe_file):
                return exe_file
    return None


def split_cxxflags(given_cxxflags, win64):
    """Split a list of flags into includes (-I...), defines (-D...), libs (-l...), lib paths (-L...), linkflags (-Wl,) and other flags (-p, -F, -framework)"""
    includes = " "
    defines = " "
    libs = " "
    libpaths = " "
    linkflags = " "
    other = " "
    # Note that -Wl,-framework may appear in the given_cxxflags
    for flag in [f.strip() for f in given_cxxflags.replace(" -framework ", " -framework" + SPECIAL_SYMBOLS).split(" ")]:
        if flag.startswith("-I"):
            if " " + flag[2:] + " " not in includes:
                includes += flag[2:] + " "
        elif flag.startswith("-D"):
            if " " + flag[2:] + " " not in defines:
                defines += flag[2:] + " "
        elif flag.startswith("-l"):
            if " " + flag[2:] + " " not in libs:
                if win64 and flag[2:] != "opengl32" and flag[2:] != "glu32":
                    libs += flag[2:] + ".dll "
                else:
                    libs += flag[2:] + " "
        elif flag.startswith("-L"):
            if " " + flag + " " not in libpaths:
                libpaths += flag + " "
        elif flag.startswith("-Wl,"):
            if (" " + flag + " " not in linkflags) and not (win64 and "-framework" in flag):
                linkflags += flag + " "
        elif flag.startswith("-p"):
            if " " + flag + " " not in other:
                other += flag + " "
        elif flag.lower().startswith("-f"):
            new_flag = flag.replace("-framework" + SPECIAL_SYMBOLS, "-framework ")
            if not win64 and " " + new_flag + " " not in linkflags:
                linkflags += new_flag + " "
            elif win64:
                new_dll = new_flag[len("-framework "):] + ".dll"
                # new_dll now contains a case-insensitive name. See if there is .dll with the same name but different casing, then use that
                for dll in chain(iglob("*.dll"), iglob("*.DLL")):
                    if dll.lower() == new_dll.lower():
                        new_dll = dll
                        break
                new_linkflag = "-l" + new_dll[:-4]
                if " " + new_linkflag + " " not in linkflags and new_linkflag != "-lFrameworks":
                    linkflags += new_linkflag + " "
                if "-L." not in linkflags:
                    linkflags += "-L. "
        elif flag.startswith("-stdlib"):
            if " " + flag + " " not in linkflags:
                linkflags += flag + " "
            if " " + flag + " " not in other:
                other += flag + " "
        else:
            # Only includes, defines, libraries, library paths and linkflags are supported
            print("WARNING: Unsupported flag: " + flag)
            continue
    # Other CXXFLAGS can be returned as the final value here
    return includes.strip(), defines.strip(), libs.strip(), libpaths.strip(), linkflags.strip(), other.strip()


def arch_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For Arch Linux."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = 'LC_ALL=C /usr/bin/pacman -Qo ' + include_path + ' | /usr/bin/cut -d" " -f5'
    package = os.popen2(cmd)[1].read().strip()
    if package in SKIP_PACKAGES:
        return ""
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = '/usr/bin/pacman -Ql ' + package + ' | /usr/bin/grep "\.pc$" | /usr/bin/cut -d" " -f2-'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        # If a library in /usr/lib matches the name of the package without .pc files, link with that
        possible_lib_name = "lib" + package + ".so"
        if not os.path.exists(os.path.join("/usr/lib", possible_lib_name)):
            print("WARNING: No pkg-config files for: " + package)
            return ""
        # Found a good candidate, matching the name of the package that owns the include file. Try that.
        return "-l" + package
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag

    return all_cxxflags.strip()


def freebsd_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For FreeBSD."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = '/usr/sbin/pkg which -q ' + include_path + ' | cut -d- -f1'
    package = os.popen2(cmd)[1].read().strip()
    if package in SKIP_PACKAGES:
        return ""
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = "/usr/sbin/pkg list " + package + " | /usr/bin/grep '\.pc$'"
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        # If a library in /usr/local/lib matches the name of the package without .pc files, link with that
        possible_lib_name = "lib" + package + ".so"
        if not os.path.exists(os.path.join("/usr/local/lib", possible_lib_name)):
            print("WARNING: No pkg-config files for: " + package)
            return ""
        # Found a good candidate, matching the name of the package that owns the include file. Try that.
        return "-l" + package
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/local/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def ubuntu_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string
    For Debian/Ubuntu."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = 'LC_ALL=C /usr/bin/dpkg-query -S ' + include_path + ' | /usr/bin/cut -d: -f1'
    package = os.popen2(cmd)[1].read().strip()
    if package in SKIP_PACKAGES:
        return ""
    if not package:
        print("ERROR: No package owns: " + include_path)
        exit(1)
    cmd = 'LC_ALL=C /usr/bin/dpkg-query -L ' + package + ' | /bin/grep "\.pc$"'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        # If a library in /usr/lib matches the name of the package without .pc files, link with that
        possible_lib_name = "lib" + package + ".so"
        if not os.path.exists(os.path.join("/usr/lib", possible_lib_name)):
            print("WARNING: No pkg-config files for: " + package)
            return ""
        # Found a good candidate, matching the name of the package that owns the include file. Try that.
        return "-l" + package
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = '/usr/bin/pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def brew_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For macOS/homebrew."""
    # Follow symlinks
    realpath = os.path.realpath(include_path)
    # If the path now starts with "/usr/local/Cellar/", then success, else return
    if not (realpath.startswith("/usr/local/Cellar/") and realpath.count("/") > 4):
        return ""
    # Strip away "/usr/local/Cellar/" from the start of the path
    package = realpath[18:].split("/")[0]
    if package in SKIP_PACKAGES:
        return ""
    # Get all .pc files that belong to the same package
    cmd = 'LC_ALL=C brew ls --verbose ' + package + ' | grep "\.pc$"'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        # If a library in /usr/local/lib matches the name of the package without .pc files, link with that
        possible_lib_name = "lib" + package + ".so"
        if not os.path.exists(os.path.join("/usr/local/lib", possible_lib_name)):
            print("WARNING: No pkg-config files for: " + package)
            return ""
        # Found a good candidate, matching the name of the package that owns the include file. Try that.
        return "-l" + package
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = 'pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = ""
        try:
            cxxflags = os.popen2(cmd)[1].read().strip()
        except OSError:
            pass
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def get_buildflags(sourcefilename, system_include_dir, win64):
    """Given a source file, try to extract the relevant includes and get pkg-config to output relevant --cflags and --libs.
    Returns includes, defines, libs, lib paths, linkflags and other cxx flags"""

    if sourcefilename == "":
        return "", "", "", "", "", ""

    # Check if pkg-config is in the PATH
    has_pkg_config = bool(which("pkg-config"))

    print("Discovering build flags for {}... ".format(sourcefilename), end="")
    stdout.flush()

    # Filter out include lines, then run cpp
    cmd = "LC_CTYPE=C && LANG=C && sed 's/^#include/" + SPECIAL_SYMBOLS + "include/g' < \"" + sourcefilename + "\" | cpp -E -P -w -pipe | sed 's/^" + SPECIAL_SYMBOLS + "include/#include/g'"
    try:
        lines = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    except:
        print("WARNING: Command failed: " + cmd)
        return "", "", "", "", "", ""
    includes = []
    for line in lines:
        if line.strip().startswith("#include"):
            if line.count("<") == 1 and line.count(">") == 1:
                includes.append(line.strip().split("<")[1].split(">")[0])
            elif line.count("\"") == 2:
                includes.append(line.strip().split("\"")[1].split("\"")[0])

    # Skip C99, C++, C++20 and deprecated C++ headers + more
    skiplist = ("assert.h", "complex.h", "ctype.h", "errno.h", "fenv.h", "float.h", "inttypes.h", "iso646.h", "limits.h", "locale.h", "math.h", "setjmp.h", "signal.h", "stdalign.h", "stdarg.h", "stdatomic.h", "stdbool.h", "stddef.h", "stdint.h", "stdio.h", "stdlib.h", "stdnoreturn.h", "string.h", "tgmath.h", "threads.h", "time.h", "uchar.h", "wchar.h", "wctype.h", "cstdlib", "csignal", "csetjmp", "cstdarg", "typeinfo", "typeindex", "type_traits", "bitset", "functional", "utility", "ctime", "chrono", "cstddef", "initializer_list", "tuple", "any", "optional", "variant", "new", "memory", "scoped_allocator", "memory_resource", "climits", "cfloat", "cstdint", "cinttypes", "limits", "exception", "stdexcept", "cassert", "system_error", "cerrno", "array", "vector", "deque", "list", "forward_list", "set", "map", "unordered_set", "unordered_map", "stack", "queue", "algorithm", "execution", "iterator", "cmath", "complex", "valarray", "random", "numeric", "ratio", "cfenv", "iosfwd", "ios", "istream", "ostream", "iostream", "fstream", "sstream", "iomanip", "streambuf", "cstdio", "locale", "clocale", "regex", "atomic", "thread", "mutex", "shared_mutex", "future", "condition_variable", "filesystem", "compare", "charconv", "syncstream", "strstream", "codecvt", "glibc", "string", "windows.h")

    # Filter out skipped includes, and includes in LOCAL_INCLUDE_PATHS
    filtered_includes = []
    for include in includes:
        if include in skiplist:
            continue
        found = False
        for local_include_path in LOCAL_INCLUDE_PATHS:
            if os.path.exists(os.path.join(local_include_path, include)):
                found = True
                break
        if not found:
            filtered_includes.append(include)
    includes = filtered_includes

    flag_dict = {}  # Map include files to flags
    global_flag_dict = {} # For -I flags, to not overwrite the flags for include files in flag_dict

    # Check for installed frameworks in /Library/Frameworks
    if os.path.exists("/Library/Frameworks"):
        # on macOS, prefer not to use pkg-config
        for include in includes:
            first_word = include
            if "/" in include:
                first_word = include.split("/")[0].strip().lower()
            if os.path.exists("/Library/Frameworks/" + first_word + ".framework"):
                # Found it!
                new_flags = "-I/usr/local/include -F/Library/Frameworks -framework " + first_word
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags

    # If the include exists in /usr/include, what is the first word, in lowercase?
    if not win64:
        for include in includes:
            if include in flag_dict:
                continue
            if os.path.exists(os.path.join(system_include_dir, include)):
                # Add the include directory as an -I flag if the include file was found
                if include in flag_dict:
                    global_flag_dict[include] += " -I" + system_include_dir
                else:
                    global_flag_dict[include] = "-I" + system_include_dir
                # If pkg-config exists, add additional flags
                if has_pkg_config:
                    # Add flags from pkg-config, if available for the first word of the include
                    first_word = include.lower()
                    if "/" in include:
                        first_word = include.split("/")[0].lower()
                    cmd = "pkg-config --cflags --libs " + first_word + " 2>/dev/null"
                    new_flags = os.popen2(cmd)[1].read().strip()
                    if new_flags:
                        if include in flag_dict:
                            flag_dict[include] += " " + new_flags
                        else:
                            flag_dict[include] = new_flags

    # Search the x86_64-w64-mingw32 path
    if win64:
        mingw_include_dir = "/usr/x86_64-w64-mingw32/include"
        for include in includes:
            if include in flag_dict:
                continue
            if os.path.exists(os.path.join(mingw_include_dir, include)):
                # Add the include directory as an -I flag if the include file was found
                if include in global_flag_dict:
                    global_flag_dict[include] += " -I" + mingw_include_dir
                else:
                    global_flag_dict[include] = "-I" + mingw_include_dir

    # If there are now missing build flags, and pkg-config is not in the path, it's a problem
    missing_includes = [include for include in includes if include not in flag_dict and include not in global_flag_dict]
    if missing_includes and not has_pkg_config:
        print("\nERROR: missing in PATH: pkg-config")
        exit(1)

    # Using the include_lines, find the correct CFLAGS on Debian/Ubuntu
    if has_pkg_config and exe("/usr/bin/dpkg-query"):
        for include in includes:
            if include in flag_dict:
                continue
            include_path = os.path.join(system_include_dir, include)
            new_flags = ubuntu_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
        # Try the same with dpkg-query, but now using find to search deeper in system_include_dir
        for include in includes:
            if include in flag_dict:
                continue
            # Search system_include_dir
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort -V | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = ubuntu_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Using the include_lines, find the correct CFLAGS on Arch Linux
    if has_pkg_config and exe("/usr/bin/pacman"):
        for include in includes:
            if include in flag_dict:
                continue
            include_path = os.path.join(system_include_dir, include)
            new_flags = arch_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
        # Try the same with pacman, but now using find to search deeper in /usr/include
        for include in includes:
            if include in flag_dict:
                continue
            # Search /usr/include
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort -V | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = arch_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Using the include_lines, find the correct CFLAGS on FreeBSD
    if has_pkg_config and exe("/usr/sbin/pkg"):
        for include in includes:
            if include in flag_dict:
                continue
            include_path = os.path.join(system_include_dir, include)
            new_flags = freebsd_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
        # Try the same, but now using find to search deeper in system_include_dir
        for include in includes:
            if include in flag_dict:
                continue
            # Search system_include_dir
            cmd = '/usr/bin/find ' + system_include_dir + ' -type f -wholename "*' + \
                include + '" | /usr/bin/sort -V | /usr/bin/tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = freebsd_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Using the include_lines, find the correct CFLAGS on macOS with Homebrew and pkg-config installed
    if has_pkg_config and which("brew"):
        for include in includes:
            if include in flag_dict:
                continue
            # Homebrew does not support finding the package that owns a file, search /usr/local/include instead
            cmd = 'find -s -L ' + system_include_dir + ' -type f -wholename "*' + include + '" | tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            new_flags = brew_include_path_to_cxxflags(include_path)
            if new_flags:
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # Special cases - additional build flags that should be reported as bugs and added to the ".pc" files that comes with libraries.
    # This must come last
    for include in includes:
        # SFML on macOS, add OpenGL and if clang, add -stdlib=libc++
        if include.split("/")[0].strip().lower() == "sfml":
            new_flags = ""
            # Check if the macOS Frameworks path exists
            if os.path.exists("/Library/Frameworks") and not win64:
                # Found it, add the OpenGL framework as well
                new_flags = "-I/usr/local/include -F/Library/Frameworks -framework OpenGL"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
                # if clang is set, add "-stdlib=libc++" when using SFML, on macOS
                if int(ARGUMENTS.get('clang', 0)):
                    if include in flag_dict:
                        flag_dict[include] += " -stdlib=libc++"
                    else:
                        flag_dict[include] = " -stdlib=libc++"
            elif win64:
                # TODO: Add cleanup of the symlink afterwards, or place it in /tmp instead
                #os.system("rm -f GL; ln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers GL")
                new_flags = "-lopengl32"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
            if has_pkg_config:
                # Try pkg-config
                cmd = "pkg-config --cflags --libs gl 2>/dev/null"
                new_flags = os.popen2(cmd)[1].read().strip()
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags
        # If one of the includes just mention something with OpenGL, or GLUT, add build flags for OpenGL
        if ("opengl" in include.lower()) or include.startswith("GL/") or include.startswith("GLUT/"):
            new_flags = ""
            # Check if the macOS Frameworks path exists
            if os.path.exists("/Library/Frameworks") and not win64:
                # Found it, add the OpenGL framework as well
                new_flags = "-I/usr/local/include -F/Library/Frameworks -framework OpenGL"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
            elif win64:
                # TODO: Add cleanup of the symlink afterwards, or place it in /tmp instead
                #os.system("rm -f GL; ln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers GL")
                new_flags = "-lopengl32"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
            if has_pkg_config:
                # Try pkg-config
                cmd = "pkg-config --cflags --libs gl 2>/dev/null"
                new_flags = os.popen2(cmd)[1].read().strip()
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags

        # If one of the includes just mention GLUT, add flags for GLUT or glu
        if include.startswith("GLUT/") or include.endswith("/glut.h"):
            new_flags = ""
            # Check if the macOS Frameworks path exists
            if os.path.exists("/Library/Frameworks") and not win64:
                # Found it, add the OpenGL framework as well
                new_flags = "-I/usr/local/include -F/Library/Frameworks -framework GLUT"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
            elif win64:
                new_flags = "-lglu32"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
            else:
                new_flags = "-lglut" # Only configuration required for ie. freeglut
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
            if has_pkg_config:
                # Try pkg-config
                cmd = "pkg-config --cflags --libs glu 2>/dev/null"
                new_flags = os.popen2(cmd)[1].read().strip()
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags

        # If one of the includes mention GLEW, add flags for GLEW
        if include.endswith("/glew.h"):
            new_flags = ""
            # Check if the macOS Frameworks path exists
            if win64:
                new_flags = "-lglew32"
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags
            if has_pkg_config:
                # Try pkg-config
                cmd = "pkg-config --cflags --libs glew 2>/dev/null"
                new_flags = os.popen2(cmd)[1].read().strip()
                if new_flags:
                    if include in flag_dict:
                        flag_dict[include] += " " + new_flags
                    else:
                        flag_dict[include] = new_flags
        if include.startswith("Q"):
            qt_include_dir = os.path.join(system_include_dir, "qt")
            if os.path.exists(qt_include_dir):
                new_flags = "-I" + qt_include_dir
                if include in flag_dict:
                    flag_dict[include] += " " + new_flags
                else:
                    flag_dict[include] = new_flags

    # List includes that were not found
    missing_includes = [include for include in includes if include not in flag_dict and include not in global_flag_dict]

    if missing_includes:
        hints(missing_includes)
        # If sloppy is set, just give a warning
        if int(ARGUMENTS.get('sloppy', 0)):
            print("WARNING: missing include: {}".format(missing_includes[0]))
        else:
            print("ERROR: missing include: {}".format(missing_includes[0]))
            exit(1)
    else:
        print("OK")

    # Collect and return all the flags in flag_dict
    all_cxxflags = (" ".join(flag_dict.values()) + " " + " ".join(global_flag_dict.values())).strip()

    if all_cxxflags:
        return split_cxxflags(all_cxxflags, win64)

    # CFLAGS, defines and libs not found
    return "", "", "", "", "", ""


def get_main_source_file(test_sources=None):
    """Get the main source file. It may be named main.cpp or main.cc, or be the only one, or the one containing 'main('.
    Return a blank string if none is found."""
    for ext in ["cpp", "cc", "cxx"]:
        if os.path.exists("main." + ext):
            return "main." + ext
    # No main source file, see if there is only one non-test source file there
    if not test_sources:
        test_sources = get_test_sources()
    all_sources = [fname for fname in chain(
        iglob("*.cpp"), iglob("*.cc"), iglob("*.cxx")) if fname not in test_sources]
    if len(all_sources) == 0:
        # No main source
        return ""
    if len(all_sources) == 1:
        # Return the 1 source file that was found
        return all_sources[0]
    # Multiple candidates for the main source file, use the one that contains the word "main("
    for fname in all_sources:
        if "main(" in open(fname).read():
            return fname
    # No source file contained "main(", there may not be a main source file here
    return ""


def get_test_sources():
    """Get all source files ending with _test.cpp, _test.cc, _test.cxx or named test.cpp, test.cc or test.cxx"""
    test_sources = list(chain(iglob("*_test.cpp"), iglob("*_test.cc"), iglob("*_test.cxx")))
    for ext in "cpp", "cc", "cxx":
        if os.path.exists("test." + ext):
            test_sources.append("test." + ext)
            break
    return test_sources


def get_dep_sources(main_source_file=None, test_sources=None):
    """Get all source files that the main executable, or test executables, may depend upon"""
    if not test_sources:
        test_sources = get_test_sources()
    if not main_source_file:
        main_source_file = get_main_source_file(test_sources)
    return [fname for fname in chain(iglob("*.cpp"), iglob("*.cc"), iglob("*.cxx")) if (fname != main_source_file) and (fname not in test_sources)]


def strip_ext(filenames):
    """Remove filename extensions from the list of filenames"""
    return [os.path.splitext(fname)[0] for fname in filenames]


def sakemake():
    """The main function"""

    # Test ELF-files to be generated. Don't add "test" here since it may be passed back to this file as an argument!
    test_sources = get_test_sources()

    # Main ELF-file to be generated
    main_source_file = get_main_source_file(test_sources)

    # Check if we are compiling for 64-bit Windows or not
    win64 = bool(int(ARGUMENTS.get('win64', 0))) # win64=1
    try:
        for line in open(main_source_file).read().split(os.linesep):
            # Check if "#include <windows.h>" exists in the main source file
            if line.strip() == "#include <windows.h>":
                win64 = True
                break
    except IOError:
        pass

    # Find all source files that are not the main source file and not test files
    dep_src = get_dep_sources(main_source_file, test_sources)

    # Test executables to be built
    test_elves = []
    if test_sources:
        test_elves = strip_ext(test_sources)

    # Main executable to be built
    main_elf = ""
    if main_source_file:
        main_elf = os.path.splitext(main_source_file)[0]
        # Add .exe extension for 64-bit Windows executables
        if win64:
            main_elf += ".exe"

    # Custom command line targets
    if 'clean' in COMMAND_LINE_TARGETS:  # Clean built executables and object files
        if (not test_elves) and (not main_elf):
            print("Nothing to clean")
            exit(0)
        # Also remove main.exe, if it's there, and win64=1
        if win64 and os.path.exists(main_elf + ".exe"):
            os.remove(main_elf + ".exe")
            print("Removed {}.exe".format(main_elf))
        # Replace the "clean" argument with "-c", and list all targets
        cmd = [x for x in argv if x != "clean"] + ["-c"] + [main_elf] + test_elves
        # Clean
        status, output = getstatusoutput(" ".join(cmd))
        output = output.strip()
        if output:
            print(output)
        exit(status)
    elif 'testbuild' in COMMAND_LINE_TARGETS:  # Build and run tests, this is the default
        # Remove the "test" argument, and list all test-executable targets
        cmd = ""
        if test_elves and main_elf:
            cmd = [x for x in argv if x != "testbuild"] + [elf for elf in test_elves + [main_elf] if elf != "testbuild"]
        elif test_elves:
            cmd = [x for x in argv if x != "testbuild"] + [elf for elf in test_elves if elf != "testbuild"]
        elif main_elf:
            cmd = [x for x in argv if x != "testbuild"] + [elf for elf in [main_elf] if elf != "testbuild"]
        else:
            print("Nothing to build")
            exit(0)
        # Build the tests/executable
        status, output = getstatusoutput(" ".join(cmd))
        output = output.strip()
        if output:
            print(output)
        exit(status)
    elif 'test' in COMMAND_LINE_TARGETS:  # Build and run tests
        if not test_elves:
            print("Nothing to test")
            exit(0)
        # Remove the "test" argument, and list all test-executable targets
        cmd = [x for x in argv if x != "test"] + [elf for elf in test_elves if elf != "test"]
        # Build the tests
        try:
            output = check_output(cmd)
        except:
            #print("Could not run: " + " ".join(cmd))
            exit(1)
        output = os.linesep.join([line for line in output.split(
            os.linesep) if not "up to date" in line]).strip()
        if output:
            print(output)
        # Run the tests
        for test_elf in test_elves:
            status, output = getstatusoutput(os.path.join(".", test_elf))
            output = output.strip()
            if output:
                print(output)
            # Exit on error
            if status != 0:
                exit(status)
        exit(0)
    elif 'run' in COMMAND_LINE_TARGETS:  # Build and run main
        # TODO: if win64==True, build an .exe and run it with wine
        # Remove the "run" argument, and add "main"
        cmd = [x for x in argv if x != "run"] + [main_elf]
        # Check if any main source file exists
        if not main_source_file:
            print("Nothing to run (no main source file)")
            exit(0)
        # Build main
        try:
            output = check_output(cmd)
        except:
            #print("Could not run: " + " ".join(cmd))
            exit(1)
        output = os.linesep.join([line for line in output.split(
            os.linesep) if not "up to date" in line]).strip()
        if output:
            print(output)
        # Run the first main elf
        if win64:
            print("wine " + main_elf)
            status, output = getstatusoutput("wine " + main_elf)
        else:
            status, output = getstatusoutput(os.path.join(".", main_elf))
        output = output.strip()
        if output:
            print(output)
        exit(status)

    # Set the number of jobs to the number of CPUs
    SetOption('num_jobs', cpu_count())

    # Random build-order, for the possiblity of using the cache better
    SetOption('random', 1)

    # Create an environment
    env = Environment()

    # Use the given CXX as the default value for the C++ compiler
    if 'CXX' in ARGUMENTS:
        env.Replace(CXX=ARGUMENTS['CXX'])

    # std is not set, use the latest C++ standard
    if not ARGUMENTS.get('std', ''):
        # Use C++17
        env.Append(CXXFLAGS=' -std=c++17')
    else:
        # if std is something else, use that
        args = []
        for key, value in ARGLIST:
            if key == 'std':
                env.Append(CXXFLAGS=' -std=' + value)

    system_include_dir = "/usr/include"
    # Set system_include_dir to the given value, or keep it as /usr/include
    if ARGUMENTS.get('system_include_dir', ''):
        system_include_dir = ARGUMENTS['system_include_dir']

    # debug is set?
    if int(ARGUMENTS.get('debug', 0)):
        env.Append(CXXFLAGS=' -Og -g -fno-omit-frame-pointer -fsanitize=address')
        if not int(ARGUMENTS.get('clang', 0)):
            env.Append(CXXFLAGS=' -static-libasan')
        env.Append(LINKFLAGS=' -fsanitize=address')
    # small is set?
    elif int(ARGUMENTS.get('small', 0)):
        env.Append(CXXFLAGS=' -Os -ffunction-sections -fdata-sections')
        env.Append(LINKFLAGS=' -ffunction-sections -fdata-sections -Wl,-s -Wl,-gc-sections')
    # opt is set?
    elif int(ARGUMENTS.get('opt', 0)):
        env.Append(CXXFLAGS=' -O3')
    # default optimization level
    else:
        env.Append(CXXFLAGS=' -O2')

    # add -pipe
    env.Append(CXXFLAGS=' -pipe -fPIC')

    # Check if a particular C++ compiler is given, or not
    if env["CXX"] == "c++":
        # Use the HEAD version of GCC as installed with Homebrew, if available
        if which("g++-HEAD"):
            env.Replace(CXX="g++-HEAD")
        else:
            env.Replace(CXX="g++")
        # clang is set?
        if int(ARGUMENTS.get('clang', 0)):
            env.Replace(CXX='clang++')

    # If "win64" is set, use the mingw32 g++ compiler
    if win64:
        env.Replace(CXX="x86_64-w64-mingw32-g++")
        env.Append(CXXFLAGS=' -Wno-unused-variable')
        env.Append(CPPFLAGS=' -mwindows -lm')
        env.Append(LINKFLAGS=' -mwindows -lm')

    # if sloppy is set, just try to build the damn thing
    if int(ARGUMENTS.get('sloppy', 0)):
        env.Append(CXXFLAGS=' -fpermissive -w')
    else:
        # if sloppy is not set, add various warnings:

        # pretty strict + fail at first error
        env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wno-parentheses -Wfatal-errors')

        # if strict is set, enable even more warnings
        if int(ARGUMENTS.get('strict', 0)):
            env.Append(CXXFLAGS=' -Wextra -Wconversion -Wparentheses -Weffc++')

    # Append any given CXXFLAGS after the other flags, to be able to override them
    if 'CXXFLAGS' in ARGUMENTS:
        env.Append(CXXFLAGS=ARGUMENTS['CXXFLAGS'])

    # add path to the include files
    env.Append(CPPPATH=LOCAL_INCLUDE_PATHS)

    # Find all included header files in ../include, then check if there are corresponding
    # sourcefiles in ../common and add them to dep_src, if there is a main source file
    if os.path.exists(main_source_file):
        includes = []
        has_new_include = True
        examined = []
        while has_new_include:
            has_new_include = False
            for INCLUDE_PATH in LOCAL_INCLUDE_PATHS:
                for filename in dep_src + [main_source_file] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
                    if filename in examined:
                        continue
                    examined.append(filename)
                    if os.path.exists(filename):
                        new_includes = [line.split("\"")[1] for line in open(filename).read().split(
                            os.linesep)[:-1] if line.strip().startswith("#include \"")]
                    else:
                        continue
                    for new_include in [os.path.relpath(x) for x in new_includes]:
                        if new_include not in includes:
                            has_new_include = True
                            includes.append(new_include)
                for include in includes:
                    for COMMON_PATH in LOCAL_COMMON_PATHS:
                        for ext in [".cpp", ".cc", ".cxx"]:
                            source_filename = os.path.join(
                                COMMON_PATH, include.rsplit(".", 1)[0] + ext)
                            if os.path.exists(source_filename):
                                if source_filename not in dep_src:
                                    dep_src.append(source_filename)

    # Find extra CFLAGS for the sources, if not cleaning
    if not (env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS):
        for src_file in [main_source_file] + dep_src:
            includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(
                src_file, system_include_dir, win64)
            if includes:
                for include in includes.split(" "):
                    env.Append(CPPPATH=include)
            if defines:
                for define in defines.split(" "):
                    env.Append(CPPDEFINES=define)
            if libs:
                env.Append(LIBS=libs.split(" "))
            if libpaths:
                env.Append(LINKFLAGS=libpaths)
            if linkflags:
                env.Append(LINKFLAGS=linkflags)
            if other_cxxflags:
                env.Append(CXXFLAGS=other_cxxflags)

    # Build main executable
    if main_source_file:
        main = env.Program(main_elf, [main_source_file] + dep_src)

    # Find extra CFLAGS for the test sources, if not cleaning
    if not (env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS):
        for src_file in test_sources:
            includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(
                src_file, system_include_dir, win64)
            if includes:
                for include in includes.split(" "):
                    env.Append(CPPPATH=include)
            if defines:
                for define in defines.split(" "):
                    env.Append(CPPDEFINES=define)
            if libs:
                env.Append(LIBS=libs.split(" "))
            if libpaths:
                env.Append(LINKFLAGS=libpaths)
            if linkflags:
                env.Append(LINKFLAGS=linkflags)
            if other_cxxflags:
                env.Append(CXXFLAGS=other_cxxflags)

    # Remove non-existing includes
    includes = [include for include in env['CPPPATH'] if os.path.exists(include)]
    # Remove duplicate includes (in terms of pointing to the same directory)
    includemap = {}
    for include in includes:
        key = os.path.normpath(include)
        if key in includemap:
            # use the shortest includepath, if several are specified for the same directory
            if len(include) < len(includemap[key]):
                if len(os.path.relpath(include)) < len(include):
                    includemap[key] = os.path.relpath(include)
                else:
                    includemap[key] = include
        else:
            if len(os.path.relpath(include)) < len(include):
                includemap[key] = os.path.relpath(include)
            else:
                includemap[key] = include
    new_includes = includemap.values()
    env.Append(CPPFLAGS=" " + " ".join(["-I" + x for x in new_includes if x != "." and x != ".."]))
    env.Replace(CPPPATH=[])
    # This also work for adding includes, but SConstruct changes them to longer versions of the same path names
    # env.Replace(CPPPATH=new_includes)

    # Set up non-default targets for all the test executables (based on *_test sources)
    for test_src in test_sources:
        test_elf = os.path.splitext(test_src)[0]
        env.Program(test_elf, [test_src] + dep_src)

    # Only main is the default target
    try:
        Default(main)
    except UnboundLocalError:
        try:
            if env.GetOption('clean') or 'clean' in COMMAND_LINE_TARGETS:
                print("Nothing to clean")
                exit(0)
        except AttributeError:
            pass
        try:
            if env.GetOption('test') or 'test' in COMMAND_LINE_TARGETS:
                print("Nothing to test")
                exit(0)
        except AttributeError:
            pass
        print("Nothing to build")


sakemake()

# vim: ts=4 sw=4 et:
