# -*- coding: utf-8 -*-

from __future__ import print_function

import commands
import glob
import multiprocessing
import os
import os.path
import subprocess
import sys

MAIN_EXECUTABLE = "main"
MAIN_SOURCE = "main.cpp"
TEST_SUFFIX = "_test.cpp"
LOCAL_INCLUDE_PATHS = ["include", "../include"]
LOCAL_COMMON_PATHS = ["common", "../common"]


def which(program):
    """Check if a program exists in PATH"""
    import os

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    return None


def split_cxxflags(given_cxxflags):
    """Split a list of flags into includes (-I...), defines (-D...), libs (-l...), lib paths (-L...), linkflags (-Wl,) and other cxxflags"""
    includes = ""
    defines = ""
    libs = ""
    libpaths = ""
    linkflags = ""
    for flag in [f.strip() for f in given_cxxflags.split(" ")]:
        if flag.startswith("-I"):
            includes += flag[2:] + " "
        elif flag.startswith("-D"):
            defines += flag[2:] + " "
        elif flag.startswith("-l"):
            libs += flag[2:] + " "
        elif flag.startswith("-L"):
            libpaths += flag + " "
        elif flag.startswith("-Wl,"):
            linkflags += flag + " "
        else:
            # Only includes, defines, libraries and library paths are supported
            print("WARNING: Unsupported flag: " + flag)
            continue
    return includes.strip(), defines.strip(), libs.strip(), libpaths.strip(), linkflags.strip(), ""


def arch_include_path_to_cxxflags(include_path):
    """Takes a path to a header file and returns cxxflags, or an empty string.
    For Arch Linux."""
    if not os.path.exists(include_path):
        return ""
    # Find the package that owns the include directory in question
    cmd = 'LC_ALL=C pacman -Qo ' + include_path + ' | cut -d" " -f5'
    package = os.popen2(cmd)[1].read().strip()
    if not package:
        print("ERROR: No package owns: " + include_path)
        sys.exit(1)
    cmd = 'pacman -Ql ' + package + ' | grep "\.pc$" | cut -d" " -f2-'
    pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
    if not pc_files:
        print("WARNING: No pkg-config files for: " + package)
        return ""
    # TODO: Consider interpreting the .pc files directly, for speed
    all_cxxflags = ""
    for pc_file in pc_files:
        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
        cmd = 'pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
        # Get the cxxflags as defined by pkg-config
        cxxflags = os.popen2(cmd)[1].read().strip()
        if cxxflags:
            for cxxflag in cxxflags.split(" "):
                if cxxflag not in all_cxxflags.split(" "):
                    all_cxxflags += " " + cxxflag
    return all_cxxflags.strip()


def get_buildflags(cppfilename, system_include_dir="/usr/include"):
    """Given a .cpp file, try to extract the relevant includes and get pkg-config to output relevant --cflags and --libs.
    Returns includes, defines, libs, lib paths, linkflags and other cxx flags"""
    try:
        lines = open(cppfilename).read().split(os.linesep)[:-1]
    except:
        return "", "", "", "", "", ""
    includes = []
    for line in lines:
        if line.strip().startswith("#include"):
            if line.count("<") == 1 and line.count(">") == 1:
                includes.append(line.strip().split("<")[1].split(">")[0])
            elif line.count("\"") == 2:
                includes.append(line.strip().split("\"")[1].split("\"")[0])

    # Skip C99, C++, C++20 and deprecated C++ headers + more
    skiplist = ("assert.h", "complex.h", "ctype.h", "errno.h", "fenv.h", "float.h", "inttypes.h", "iso646.h", "limits.h", "locale.h", "math.h", "setjmp.h", "signal.h", "stdalign.h", "stdarg.h", "stdatomic.h", "stdbool.h", "stddef.h", "stdint.h", "stdio.h", "stdlib.h", "stdnoreturn.h", "string.h", "tgmath.h", "threads.h", "time.h", "uchar.h", "wchar.h", "wctype.h", "cstdlib", "csignal", "csetjmp", "cstdarg", "typeinfo", "typeindex", "type_traits", "bitset", "functional", "utility", "ctime", "chrono", "cstddef", "initializer_list", "tuple", "any", "optional", "variant", "new", "memory", "scoped_allocator", "memory_resource", "climits",
                "cfloat", "cstdint", "cinttypes", "limits", "exception", "stdexcept", "cassert", "system_error", "cerrno", "array", "vector", "deque", "list", "forward_list", "set", "map", "unordered_set", "unordered_map", "stack", "queue", "algorithm", "execution", "iterator", "cmath", "complex", "valarray", "random", "numeric", "ratio", "cfenv", "iosfwd", "ios", "istream", "ostream", "iostream", "fstream", "sstream", "iomanip", "streambuf", "cstdio", "locale", "clocale", "regex", "atomic", "thread", "mutex", "shared_mutex", "future", "condition_variable", "filesystem", "compare", "charconv", "syncstream", "strstream", "codecvt", "glibc")

    includes = [x for x in includes if x not in skiplist]

    if os.path.exists("/Library/Frameworks"):
        # on macOS, prefer not to use pkg-config
        for include in includes:
            first_word = include
            if "/" in include:
                first_word = include.split("/")[0].lower()
            if os.path.exists("/Library/Frameworks/" + first_word + ".framework"):
                # Found it!
                return "", "", "", "", "", "-F/Library/Frameworks -framework " + first_word

    if not which("pkg-config"):
        print("NOTE: pkg-config must be installed for library-detection to work")
        return "", "", "", "", "", ""

    # If the include exists in /usr/include, what is the first word, in lowercase?
    for include in includes:
        if os.path.exists(os.path.join(system_include_dir, include)):
            first_word = include.lower()
            if "/" in include:
                first_word = include.split("/")[0].lower()
            cmd = "pkg-config --cflags --libs " + first_word + " 2>/dev/null"
            data = os.popen2(cmd)[1].read()
            if data:
                return split_cxxflags(data)

    # Using the include_lines, find the correct CFLAGS on Arch Linux
    if which("pacman"):
        for include in includes:
            include_path = os.path.join(system_include_dir, include)
            all_cxxflags = arch_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)
        # Now try the same with pacman, but now using find to search deeper in /usr/include
        for include in includes:
            # Search /usr/include
            cmd = 'find /usr/include -type f -wholename "*' + include + '" | tail -1'
            include_path = os.popen2(cmd)[1].read().strip()
            all_cxxflags = arch_include_path_to_cxxflags(include_path)
            if all_cxxflags:
                return split_cxxflags(all_cxxflags)

    # Using the include_lines, find the correct CFLAGS on Debian/Ubuntu
    if which("dpkg-query"):
        for include in includes:
            include_path = os.path.join(system_include_dir, include)
            if os.path.exists(include_path):
                # Find the package that owns the include directory in question
                cmd = 'LC_ALL=C dpkg-query -S ' + include_path + ' | cut -d" " -f2-'
                package = os.popen2(cmd)[1].read().strip()
                if not package:
                    print("ERROR: No package owns: " + include_path)
                    sys.exit(1)
                cmd = 'dpkg-query -L ' + package + ' | grep "\.pc$"'
                pc_files = os.popen2(cmd)[1].read().split(os.linesep)[:-1]
                if not pc_files:
                    print("WARNING: No pkg-config files for: " + package)
                    continue
                # TODO: Consider interpreting the .pc files directly, for speed
                all_cxxflags = ""
                for pc_file in pc_files:
                    pc_name = os.path.splitext(os.path.basename(pc_file))[0]
                    cmd = 'pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
                    # Get the cxxflags as defined by pkg-config
                    cxxflags = os.popen2(cmd)[1].read().strip()
                    if cxxflags:
                        for cxxflag in cxxflags.split(" "):
                            if cxxflag not in all_cxxflags.split(" "):
                                all_cxxflags += " " + cxxflag
                if all_cxxflags:
                    return split_cxxflags(all_cxxflags.strip())

    # Using the include_lines, find the correct CFLAGS on macOS with Homebrew and pkg-config installed
    if which("brew"):
        for include in includes:
            # Homebrew does not support finding the package that owns a file, search /usr/local/include instead
            cmd = 'find -s -L /usr/local/include -type f -wholename "*' + include + '" | tail -1'
            result = os.popen2(cmd)[1].read().strip()
            realpath = os.path.realpath(result)
            # If the path now starts with "/usr/local/Cellar/", then success
            if realpath.startswith("/usr/local/Cellar/") and realpath.count("/") > 4:
                # Strip away "/usr/local/Cellar/" from the start of the path
                package = realpath[18:].split("/")[0]
                # Get all .pc files that belong to the same package
                cmd = 'brew ls --verbose ' + package + ' | grep "\.pc$"'
                result = os.popen2(cmd)[1].read().strip()
                if result:
                    pc_files = result.split(os.linesep)
                    if not pc_files:
                        print("WARNING: No pkg-config files for: " + package)
                        continue
                    # TODO: Consider interpreting the .pc files directly, for speed
                    all_cxxflags = ""
                    for pc_file in pc_files:
                        pc_name = os.path.splitext(os.path.basename(pc_file))[0]
                        cmd = 'pkg-config --cflags --libs ' + pc_name + ' 2>/dev/null'
                        # Get the cxxflags as defined by pkg-config
                        cxxflags = os.popen2(cmd)[1].read().strip()
                        if cxxflags:
                            for cxxflag in cxxflags.split(" "):
                                if cxxflag not in all_cxxflags.split(" "):
                                    all_cxxflags += " " + cxxflag
                    if all_cxxflags:
                        return split_cxxflags(all_cxxflags.strip())

    # CFLAGS, defines and libs not found
    return "", "", "", "", "", ""


# Test ELF-files to be generated. Don't add "test" here since it may be passed back to this file as an argument!
test_elves = [os.path.splitext(fn)[0] for fn in glob.glob("*" + TEST_SUFFIX)]

# Custom command line targets
if 'clean' in COMMAND_LINE_TARGETS:  # Clean built executables and object files
    # Replace the "clean" argument with "-c", and list all targets
    cmd = [x for x in sys.argv if x != "clean"] + ["-c"] + [MAIN_EXECUTABLE] + test_elves
    # Clean
    status, output = commands.getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)
elif 'testbuild' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "testbuild"] + test_elves
    # Build the tests
    status, output = commands.getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)
elif 'test' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "test"] + test_elves
    # Build the tests
    output = subprocess.check_output(cmd)
    output = os.linesep.join([line for line in output.split(
        os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run the tests
    for ELF in test_elves:
        status, output = commands.getstatusoutput(os.path.join(".", ELF))
        output = output.strip()
        if output:
            print(output)
        # Exit on error
        if status != 0:
            sys.exit(status)
    sys.exit(0)
elif 'run' in COMMAND_LINE_TARGETS:  # Build and run main
    # Remove the "run" argument, and add "main"
    cmd = [x for x in sys.argv if x != "run"] + [MAIN_EXECUTABLE]
    # Check if main.cpp exists
    if not os.path.exists(MAIN_SOURCE):
        print("Nothing to run (no " + MAIN_SOURCE + ")")
        sys.exit(0)
    # Build main
    output = subprocess.check_output(cmd)
    output = os.linesep.join([line for line in output.split(
        os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run main
    status, output = commands.getstatusoutput(os.path.join(".", MAIN_EXECUTABLE))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)

# Set the number of jobs to the number of CPUs
SetOption('num_jobs', multiprocessing.cpu_count())

# Random build-order, for the possiblity of using the cache better
SetOption('random', 1)

# Create an environment
env = Environment()

# std is not set, use the latest C++ standard
if not ARGUMENTS.get('std', ''):
    # Use C++17
    env.Append(CXXFLAGS=' -std=c++17')
else:
    # if std is something else, use that
    args = []
    for key, value in ARGLIST:
        if key == 'std':
            env.Append(CXXFLAGS=' -std=' + value)

# debug is set?
if int(ARGUMENTS.get('debug', 0)):
    env.Append(CXXFLAGS=' -Og -g -fno-omit-frame-pointer -fsanitize=address')
    env.Append(LINKFLAGS=' -fsanitize=address')
else:
    env.Append(CXXFLAGS=' -O2')

# opt is set?
if int(ARGUMENTS.get('opt', 0)):
    env.Append(CXXFLAGS=' -O3')

# clang is set?
if int(ARGUMENTS.get('clang', 0)):
    env.Replace(CXX='clang++')

# Use the HEAD version of GCC as installed with Homebrew, if available
if env["CXX"] == "g++" and which("g++-HEAD"):
    env.Replace(CXX="g++-HEAD")

# if sloppy is set, just try to build the damn thing
if int(ARGUMENTS.get('sloppy', 0)):
    env.Append(CXXFLAGS=' -fpermissive -w')
else:
    # if sloppy is not set, add various warnings:

    # pretty strict + fail at first error
    env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wfatal-errors')

    # if strict is set, enable even more warnings
    if int(ARGUMENTS.get('strict', 0)):
        env.Append(CXXFLAGS=' -Wextra -Wconversion -Weffc++')

# Find all .cpp files that are not not *_test.cpp, not main.cpp and not test.cpp
dep_src = [fn for fn in glob.glob("*.cpp") if not fn.endswith(TEST_SUFFIX)
           and fn != MAIN_SOURCE and fn != "test.cpp"]

# add path to the include files
env.Append(CPPPATH=LOCAL_INCLUDE_PATHS)

# Find all included header files in ../include, then check if there are corresponding .cpp files in ../common and add them to dep_src, if there is a main source file
if os.path.exists(MAIN_SOURCE):
    includes = []
    has_new_include = True
    examined = []
    while has_new_include:
        has_new_include = False
        for INCLUDE_PATH in LOCAL_INCLUDE_PATHS:
            for filename in dep_src + [MAIN_SOURCE] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
                if filename in examined:
                    continue
                examined.append(filename)
                if os.path.exists(filename):
                    new_includes = [line.split("\"")[1] for line in open(filename).read().split(
                        os.linesep)[:-1] if line.strip().startswith("#include \"")]
                else:
                    continue
                for new_include in [os.path.relpath(x) for x in new_includes]:
                    if new_include not in includes:
                        has_new_include = True
                        includes.append(new_include)
            for include in includes:
                for COMMON_PATH in LOCAL_COMMON_PATHS:
                    source_filename = os.path.join(COMMON_PATH, include.rsplit(".", 1)[0] + ".cpp")
                    if os.path.exists(source_filename):
                        if source_filename not in dep_src:
                            dep_src.append(source_filename)

# Find extra CFLAGS for the sources, if not cleaning
if not env.GetOption('clean'):
    for src_file in [MAIN_SOURCE] + dep_src:
        includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(src_file)
        if includes:
            for include in includes.split(" "):
                env.Append(CPPPATH=include)
        if defines:
            for define in defines.split(" "):
                env.Append(CPPDEFINES=define)
        if libs:
            env.Append(LIBS=libs.split(" "))
        if libpaths:
            env.Append(LINKFLAGS=libpaths)
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if other_cxxflags:
            env.Append(CXXFLAGS=other_cxxflags)

# Build main executable
main = env.Program(MAIN_EXECUTABLE, [MAIN_SOURCE] + dep_src)

# Find extra CFLAGS for the test sources, if not cleaning
if not env.GetOption('clean'):
    for src_file in [ELF + ".cpp" for ELF in test_elves]:
        includes, defines, libs, libpaths, linkflags, other_cxxflags = get_buildflags(src_file)
        if includes:
            for include in includes.split(" "):
                env.Append(CPPPATH=include)
        if defines:
            for define in defines.split(" "):
                env.Append(CPPDEFINES=define)
        if libs:
            env.Append(LIBS=libs.split(" "))
        if libpaths:
            env.Append(LINKFLAGS=libpaths)
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if other_cxxflags:
            env.Append(CXXFLAGS=other_cxxflags)

# Remove non-existing includes
includes = [include for include in env['CPPPATH'] if os.path.exists(include)]
# Remove duplicate includes (in terms of pointing to the same directory)
includemap = {}
for include in includes:
    key = os.path.normpath(include)
    if key in includemap:
        # use the shortest includepath, if several are specified for the same directory
        if len(include) < len(includemap[key]):
            if len(os.path.relpath(include)) < len(include):
                includemap[key] = os.path.relpath(include)
            else:
                includemap[key] = include
    else:
        if len(os.path.relpath(include)) < len(include):
            includemap[key] = os.path.relpath(include)
        else:
            includemap[key] = include
new_includes = includemap.values()
env.Append(CPPFLAGS=" ".join(["-I" + x for x in new_includes]))
env.Replace(CPPPATH=[])
# This also work for adding includes, but SConstruct changes them to longer versions
# env.Replace(CPPPATH=new_includes)

# Set up non-default targets for all the test executables (based on *_test.cpp)
for ELF in test_elves:
    env.Program(ELF, [ELF + ".cpp"] + dep_src)

# Only main is the default target
Default(main)

# vim: ts=4 sw=4 et:
