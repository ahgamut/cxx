# -*- coding: utf-8 -*-

from __future__ import print_function

import commands
import glob
import multiprocessing
import os
import os.path
import subprocess
import sys

MAIN_SOURCE = "main.cpp"
TEST_SUFFIX = "_test.cpp"
LOCAL_INCLUDE_PATHS = ["include", "../include"]
LOCAL_COMMON_PATHS = ["common", "../common"]


def which(program):
    """Check if a program exists in PATH"""
    import os

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    return None


def split_cflags(cflags):
    """Split a list of flags into includes (-I...), defines (-D...) and linking (-l...)"""
    includeflags = ""
    defineflags = ""
    libflags = ""
    for flag in cflags.split(" "):
        if flag.strip().startswith("-I"):
            includeflags += flag.strip() + " "
        elif flag.strip().startswith("-D"):
            defineflags += flag.strip()[2:] + " "
        elif flag.strip().startswith("-l"):
            libflags += flag.strip()[2:] + " "
        else:
            # Only includes, defines and libs are supported
            continue
    return includeflags.strip(), defineflags.strip(), libflags.strip()


def get_cflags_defines_and_libs(cppfilename, system_include_dir="/usr/include"):
    """Given a .cpp file, try to extract the relevant includes and get pkg-config to output relevant --cflags and --libs"""
    lines = open(cppfilename).read().split("\n")[:-1]
    includes = []
    for line in lines:
        if line.strip().startswith("#include"):
            try:
                includes.append(line.strip().split("<")[1].split(">")[0])
            except IndexError:
                continue

    if not which("pkg-config"):
        print("NOTE: pkg-config must be installed for library-detection to work")
        return "", "", ""

    # If the include exists in /usr/include, what is the first word, in lowercase?
    for include in includes:
        if glob.glob(os.path.join(system_include_dir, include)):
            first_word = include.lower()
            if "/" in include:
                first_word = include.split("/")[0].lower()
            cmd = "pkg-config --cflags --libs " + first_word
            data = os.popen2(cmd)[1].read()
            if data:
                return split_cflags(data)

    # Using the include_lines, find the correct CFLAGS on Arch Linux
    if which("pacman") and which("pkg-config") and which("cut"):
        for include in includes:
            include_path = os.path.join(system_include_dir, include)
            if glob.glob(include_path):
                cmd = 'pkg-config --cflags --libs $(LC_ALL=C pacman -Qo ' + \
                    include_path + ' | cut -d" " -f5)'
                # Return the CFLAGS as defined by pkg-config
                data = os.popen2(cmd)[1].read()
                if data:
                    return split_cflags(data)

    # TODO: Add Debian support here

    # CFLAGS, defines and libs not found
    return "", "", ""


# Test ELF-files to be generated
test_elves = [os.path.splitext(fn)[0] for fn in glob.glob("*" + TEST_SUFFIX)]

# Custom command line targets
if 'clean' in COMMAND_LINE_TARGETS:  # Clean built executables and object files
    # Replace the "clean" argument with "-c", and list all targets
    cmd = [x for x in sys.argv if x != "clean"] + ["-c"] + ["main"] + test_elves
    # Clean
    status, output = commands.getstatusoutput(" ".join(cmd))
    output = os.linesep.join(output.split(os.linesep)[0:-1])
    if output:
        print(output)
    sys.exit(status)
elif 'testbuild' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "testbuild"] + test_elves
    # Build the tests
    status, output = commands.getstatusoutput(" ".join(cmd))
    print(os.linesep.join(output.split(os.linesep)[1:-1]))
    sys.exit(status)
elif 'test' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "test"] + test_elves
    # Build the tests
    output = subprocess.check_output(cmd)
    print(os.linesep.join(output.split(os.linesep)[1:-1]))
    # Run the tests
    for ELF in test_elves:
        status, output = commands.getstatusoutput(os.path.join(".", ELF))
        print(output)
        # Exit on error
        if status != 0:
            sys.exit(status)
    sys.exit(0)
elif 'run' in COMMAND_LINE_TARGETS:  # Build and run main
    # Remove the "run" argument, and add "main"
    cmd = [x for x in sys.argv if x != "run"] + ["main"]
    # Build main
    output = subprocess.check_output(cmd)
    print(os.linesep.join(output.split(os.linesep)[1:-1]))
    # Run main
    ELF = "main"
    status, output = commands.getstatusoutput(os.path.join(".", ELF))
    print(output)
    sys.exit(status)

# Set the number of jobs to the number of CPUs
SetOption('num_jobs', multiprocessing.cpu_count())

# Random build-order, for the possiblity of using the cache better
SetOption('random', 1)

# Compiler and compiler flags
env = Environment(CXX="g++",
                  CXXFLAGS='-std=c++17')

# debug=1
if int(ARGUMENTS.get('debug', 0)):
    env.Append(CXXFLAGS=' -O1 -g')
else:
    env.Append(CXXFLAGS=' -O2')

# opt=1
if int(ARGUMENTS.get('opt', 0)):
    env.Append(CXXFLAGS=' -O3')

# clang=1
if int(ARGUMENTS.get('clang', 0)):
    env.Replace(CXX='clang++')

# Warnings and fail at first error
env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wfatal-errors')

# extra=1, even more warnings
if int(ARGUMENTS.get('extra', 0)):
    env.Append(CXXFLAGS=' -Wextra')

# Find all .cpp files that are not main.cpp and not *_test.cpp
dep_src = [fn for fn in glob.glob("*.cpp") if not fn.endswith(TEST_SUFFIX) and fn != MAIN_SOURCE]

# add path to the include files
env.Append(CPPPATH=LOCAL_INCLUDE_PATHS)

# Find all included header files in ../include, then check if there are corresponding .cpp files in ../common and add them to dep_src, if there is a main source file
if glob.glob(MAIN_SOURCE):
    includes = []
    has_new_include = True
    examined = []
    while has_new_include:
        has_new_include = False
        for INCLUDE_PATH in LOCAL_INCLUDE_PATHS:
            for filename in dep_src + [MAIN_SOURCE] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
                if filename in examined:
                    continue
                examined.append(filename)
                if glob.glob(filename):
                    new_includes = [line.split("\"")[1] for line in open(filename).read().split(
                        os.linesep)[:-1] if line.strip().startswith("#include \"")]
                else:
                    continue
                for new_include in new_includes:
                    if new_include not in includes:
                        has_new_include = True
                        includes.append(new_include)
            for include in includes:
                for COMMON_PATH in LOCAL_COMMON_PATHS:
                    source_filename = os.path.join(COMMON_PATH, include.rsplit(".", 1)[0] + ".cpp")
                    if glob.glob(source_filename):
                        if source_filename not in dep_src:
                            dep_src.append(source_filename)

# Find extra CFLAGS for the sources, if not cleaning
if not env.GetOption('clean'):
    for src_file in [MAIN_SOURCE] + dep_src:
        cflags, defines, libs = get_cflags_defines_and_libs(src_file)
        if cflags:
            env.Append(CXXFLAGS=' ' + cflags)
        if defines:
            env.Append(CPPDEFINES=defines)
        if libs:
            env.Append(LIBS=libs)

# Build main executable
main = env.Program("main", [MAIN_SOURCE] + dep_src)

# Find extra CFLAGS for the test sources, if not cleaning
if not env.GetOption('clean'):
    for ELF in test_elves:
        cflags, defines, libs = get_cflags_defines_and_libs(ELF + ".cpp")
        if cflags:
            env.Append(CXXFLAGS=' ' + cflags)
        if defines:
            env.Append(CPPDEFINES=defines)
        if libs:
            env.Append(LIBS=libs)

# Set up non-default targets for all the test executables (based on *_test.cpp)
for ELF in test_elves:
    env.Program(ELF, [ELF + ".cpp"] + dep_src)

# Only main is the default target
Default(main)

# vim: ts=4 sw=4 et:
