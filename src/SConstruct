# -*- coding: utf-8 -*-

from __future__ import print_function

import commands
import glob
import multiprocessing
import os
import os.path
import subprocess
import sys

MAIN_EXECUTABLE = "main"
MAIN_SOURCE = "main.cpp"
TEST_SUFFIX = "_test.cpp"
LOCAL_INCLUDE_PATHS = ["include", "../include"]
LOCAL_COMMON_PATHS = ["common", "../common"]

def which(program):
    """Check if a program exists in PATH"""
    import os

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    return None


def split_cflags(cflags):
    """Split a list of flags into includes (-I...), defines (-D...) and libs (-l...)"""
    includes = ""
    defines = ""
    libs = ""
    for flag in cflags.split(" "):
        if flag.strip().startswith("-I"):
            includes += flag.strip()[2:] + " "
        elif flag.strip().startswith("-D"):
            defines += flag.strip()[2:] + " "
        elif flag.strip().startswith("-l"):
            libs += flag.strip()[2:] + " "
        else:
            # Only includes, defines and libs are supported
            continue
    return includes.strip(), defines.strip(), libs.strip(), ""


def get_includes_defines_libs_linkflags_and_cflags(cppfilename, system_include_dir="/usr/include"):
    """Given a .cpp file, try to extract the relevant includes and get pkg-config to output relevant --cflags and --libs"""
    try:
        lines = open(cppfilename).read().split(os.linesep)[:-1]
    except:
        return "", "", "", "", ""
    includes = []
    for line in lines:
        if line.strip().startswith("#include"):
            try:
                includes.append(line.strip().split("<")[1].split(">")[0])
            except IndexError:
                continue

    if os.path.exists("/Library/Frameworks"):
        # on macOS, prefer not to use pkg-config
        for include in includes:
            first_word = include
            if "/" in include:
                first_word = include.split("/")[0].lower()
            if os.path.exists("/Library/Frameworks/" + first_word + ".framework"):
                # Found it!
                return "", "", "", "", "-F/Library/Frameworks -framework " + first_word

    if not which("pkg-config"):
        print("NOTE: pkg-config must be installed for library-detection to work")
        return "", "", "", "", ""

    # If the include exists in /usr/include, what is the first word, in lowercase?
    for include in includes:
        if os.path.exists(os.path.join(system_include_dir, include)):
            first_word = include.lower()
            if "/" in include:
                first_word = include.split("/")[0].lower()
            cmd = "pkg-config --cflags --libs " + first_word
            data = os.popen2(cmd)[1].read()
            if data:
                return split_cflags(data)

    # Using the include_lines, find the correct CFLAGS on Arch Linux
    if which("pacman") and which("pkg-config") and which("cut"):
        for include in includes:
            include_path = os.path.join(system_include_dir, include)
            if glob.glob(include_path):
                cmd = 'pkg-config --cflags --libs $(LC_ALL=C pacman -Qo ' + \
                    include_path + ' | cut -d" " -f5)'
                # Return the CFLAGS as defined by pkg-config
                data = os.popen2(cmd)[1].read()
                if data:
                    return split_cflags(data)

    # TODO: Add Debian support here

    # CFLAGS, defines and libs not found
    return "", "", "", "", ""


# Test ELF-files to be generated
test_elves = [os.path.splitext(fn)[0] for fn in glob.glob("*" + TEST_SUFFIX)]

# Custom command line targets
if 'clean' in COMMAND_LINE_TARGETS:  # Clean built executables and object files
    # Replace the "clean" argument with "-c", and list all targets
    cmd = [x for x in sys.argv if x != "clean"] + ["-c"] + [MAIN_EXECUTABLE] + test_elves
    # Clean
    status, output = commands.getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)
elif 'testbuild' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "testbuild"] + test_elves
    # Build the tests
    status, output = commands.getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)
elif 'test' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "test"] + test_elves
    # Build the tests
    output = subprocess.check_output(cmd)
    output = os.linesep.join([line for line in output.split(os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run the tests
    for ELF in test_elves:
        status, output = commands.getstatusoutput(os.path.join(".", ELF))
        print(output.strip())
        # Exit on error
        if status != 0:
            sys.exit(status)
    sys.exit(0)
elif 'run' in COMMAND_LINE_TARGETS:  # Build and run main
    # Remove the "run" argument, and add "main"
    cmd = [x for x in sys.argv if x != "run"] + [MAIN_EXECUTABLE]
    # Check if main.cpp exists
    if not glob.glob(MAIN_SOURCE):
        print("Nothing to run (no " + MAIN_SOURCE + ")")
        sys.exit(0)
    # Build main
    output = subprocess.check_output(cmd)
    output = os.linesep.join([line for line in output.split(os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run main
    status, output = commands.getstatusoutput(os.path.join(".", MAIN_EXECUTABLE))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)

# Set the number of jobs to the number of CPUs
SetOption('num_jobs', multiprocessing.cpu_count())

# Random build-order, for the possiblity of using the cache better
SetOption('random', 1)

# Compiler and compiler flags
env = Environment(CXX="g++",
                  CXXFLAGS='-std=c++14')

# debug=1
if int(ARGUMENTS.get('debug', 0)):
    env.Append(CXXFLAGS=' -O1 -g')
else:
    env.Append(CXXFLAGS=' -O2')

# opt=1
if int(ARGUMENTS.get('opt', 0)):
    env.Append(CXXFLAGS=' -O3')

# clang=1
if int(ARGUMENTS.get('clang', 0)):
    env.Replace(CXX='clang++')

# Warnings and fail at first error
env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wfatal-errors')

# extra=1, even more warnings
if int(ARGUMENTS.get('extra', 0)):
    env.Append(CXXFLAGS=' -Wextra -Wconversion -Weffc++')

# Find all .cpp files that are not main.cpp and not *_test.cpp
dep_src = [fn for fn in glob.glob("*.cpp") if not fn.endswith(TEST_SUFFIX) and fn != MAIN_SOURCE]

# add path to the include files
env.Append(CPPPATH=LOCAL_INCLUDE_PATHS)

# Find all included header files in ../include, then check if there are corresponding .cpp files in ../common and add them to dep_src, if there is a main source file
if glob.glob(MAIN_SOURCE):
    includes = []
    has_new_include = True
    examined = []
    while has_new_include:
        has_new_include = False
        for INCLUDE_PATH in LOCAL_INCLUDE_PATHS:
            for filename in dep_src + [MAIN_SOURCE] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
                if filename in examined:
                    continue
                examined.append(filename)
                if glob.glob(filename):
                    new_includes = [line.split("\"")[1] for line in open(filename).read().split(
                        os.linesep)[:-1] if line.strip().startswith("#include \"")]
                else:
                    continue
                for new_include in [os.path.relpath(x) for x in new_includes]:
                    if new_include not in includes:
                        has_new_include = True
                        includes.append(new_include)
            for include in includes:
                for COMMON_PATH in LOCAL_COMMON_PATHS:
                    source_filename = os.path.join(COMMON_PATH, include.rsplit(".", 1)[0] + ".cpp")
                    if glob.glob(source_filename):
                        if source_filename not in dep_src:
                            dep_src.append(source_filename)

# Find extra CFLAGS for the sources, if not cleaning
if not env.GetOption('clean'):
    for src_file in [MAIN_SOURCE] + dep_src:
        includes, defines, libs, linkflags, cflags = get_includes_defines_libs_linkflags_and_cflags(src_file)
        if includes:
            env.Append(CPPPATH=includes)
        if defines:
            env.Append(CPPDEFINES=defines)
        if libs:
            env.Append(LIBS=libs)
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if cflags:
            env.Append(CPPFLAGS=cflags)

# Build main executable
main = env.Program(MAIN_EXECUTABLE, [MAIN_SOURCE] + dep_src)

# Find extra CFLAGS for the test sources, if not cleaning
if not env.GetOption('clean'):
    for ELF in test_elves:
        includes, defines, libs, linkflags, cflags = get_includes_defines_libs_linkflags_and_cflags(ELF + ".cpp")
        if includes:
            env.Append(CPPPATH=includes)
        if defines:
            env.Append(CPPDEFINES=defines)
        if libs:
            env.Append(LIBS=libs)
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if cflags:
            env.Append(CPPFLAGS=cflags)

## Remove non-existing includes
includes = [include for include in env['CPPPATH'] if os.path.exists(include)]
# Remove duplicate includes (in terms of pointing to the same directory)
includemap = {}
for include in includes:
    key = os.path.normpath(include)
    if key in includemap:
        # use the shortest includepath, if several are specified for the same directory
        if len(include) < len(includemap[key]):
            if len(os.path.relpath(include)) < len(include):
                includemap[key] = os.path.relpath(include)
            else:
                includemap[key] = include
    else:
        if len(os.path.relpath(include)) < len(include):
            includemap[key] = os.path.relpath(include)
        else:
            includemap[key] = include
new_includes = includemap.values()
env.Append(CPPFLAGS=" ".join(["-I" + x for x in new_includes]))
env.Replace(CPPPATH=[])
# This also work for adding includes, but SConstruct changes them to longer versions
#env.Replace(CPPPATH=new_includes)

# Set up non-default targets for all the test executables (based on *_test.cpp)
for ELF in test_elves:
    env.Program(ELF, [ELF + ".cpp"] + dep_src)

# Only main is the default target
Default(main)

# vim: ts=4 sw=4 et:
