# -*- coding: utf-8 -*-

from __future__ import print_function

import commands
import glob
import multiprocessing
import os
import os.path
import subprocess
import sys

MAIN_EXECUTABLE = "main"
MAIN_SOURCE = "main.cpp"
TEST_SUFFIX = "_test.cpp"
LOCAL_INCLUDE_PATHS = ["include", "../include"]
LOCAL_COMMON_PATHS = ["common", "../common"]

def which(program):
    """Check if a program exists in PATH"""
    import os

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file
    return None


def split_cflags(given_cflags):
    """Split a list of flags into includes (-I...), defines (-D...), libs (-l...), lib paths (-L...) and ignored"""
    includes = ""
    defines = ""
    libs = ""
    libpaths = ""
    for flag in given_cflags.split(" "):
        if flag.strip().startswith("-I"):
            includes += flag.strip()[2:] + " "
        elif flag.strip().startswith("-D"):
            defines += flag.strip()[2:] + " "
        elif flag.strip().startswith("-l"):
            libs += flag.strip()[2:] + " "
        elif flag.strip().startswith("-L"):
            libpaths += flag.strip() + " "
        else:
            # Only includes, defines, libraries and library paths are supported
            print("WARNING: Unsupported flag: " + flag)
            continue
    return includes.strip(), defines.strip(), libs.strip(), libpaths.strip(), ""


def get_includes_defines_libs_linkflags_and_cflags(cppfilename, system_include_dir="/usr/include"):
    """Given a .cpp file, try to extract the relevant includes and get pkg-config to output relevant --cflags and --libs"""
    try:
        lines = open(cppfilename).read().split(os.linesep)[:-1]
    except:
        return "", "", "", "", ""
    includes = []
    for line in lines:
        if line.strip().startswith("#include"):
            if line.count("<") == 1 and line.count(">") == 1:
                includes.append(line.strip().split("<")[1].split(">")[0])
            elif line.count("\"") == 2:
                includes.append(line.strip().split("\"")[1].split("\"")[0])

    # Skip C99, C++, C++20 and deprecated C++ headers
    skiplist = ("assert.h", "complex.h", "ctype.h", "errno.h", "fenv.h", "float.h", "inttypes.h", "iso646.h", "limits.h", "locale.h", "math.h", "setjmp.h", "signal.h", "stdalign.h", "stdarg.h", "stdatomic.h", "stdbool.h", "stddef.h", "stdint.h", "stdio.h", "stdlib.h", "stdnoreturn.h", "string.h", "tgmath.h", "threads.h", "time.h", "uchar.h", "wchar.h", "wctype.h", "cstdlib", "csignal", "csetjmp", "cstdarg", "typeinfo", "typeindex", "type_traits", "bitset", "functional", "utility", "ctime", "chrono", "cstddef", "initializer_list", "tuple", "any", "optional", "variant", "new", "memory", "scoped_allocator", "memory_resource", "climits", "cfloat", "cstdint", "cinttypes", "limits", "exception", "stdexcept", "cassert", "system_error", "cerrno", "array", "vector", "deque", "list", "forward_list", "set", "map", "unordered_set", "unordered_map", "stack", "queue", "algorithm", "execution", "iterator", "cmath", "complex", "valarray", "random", "numeric", "ratio", "cfenv", "iosfwd", "ios", "istream", "ostream", "iostream", "fstream", "sstream", "iomanip", "streambuf", "cstdio", "locale", "clocale", "regex", "atomic", "thread", "mutex", "shared_mutex", "future", "condition_variable", "filesystem", "compare", "charconv", "syncstream", "strstream", "codecvt")

    includes = [x for x in includes if x not in skiplist]

    if os.path.exists("/Library/Frameworks"):
        # on macOS, prefer not to use pkg-config
        for include in includes:
            first_word = include
            if "/" in include:
                first_word = include.split("/")[0].lower()
            if os.path.exists("/Library/Frameworks/" + first_word + ".framework"):
                # Found it!
                #print("Found " + first_word)
                return "", "", "", "", "-F/Library/Frameworks -framework " + first_word

    if not which("pkg-config"):
        print("NOTE: pkg-config must be installed for library-detection to work")
        return "", "", "", "", ""

    # If the include exists in /usr/include, what is the first word, in lowercase?
    for include in includes:
        if os.path.exists(os.path.join(system_include_dir, include)):
            first_word = include.lower()
            if "/" in include:
                first_word = include.split("/")[0].lower()
            cmd = "pkg-config --cflags --libs " + first_word + " 2>/dev/null"
            data = os.popen2(cmd)[1].read()
            if data:
                #print("Found " + first_word)
                return split_cflags(data)

    # Using the include_lines, find the correct CFLAGS on Arch Linux
    if which("pacman") and which("pkg-config") and which("cut"):
        for include in includes:
            print("TRYING ARCH METHOD FOR " + include)
            include_path = os.path.join(system_include_dir, include)
            if os.path.exists(include_path):
                cmd = 'pkg-config --cflags --libs $(LC_ALL=C pacman -Qo ' + \
                    include_path + ' | cut -d" " -f5) 2>/dev/null'
                # Return the CFLAGS as defined by pkg-config
                data = os.popen2(cmd)[1].read()
                if data:
                    #print("Found " + first_word)
                    return split_cflags(data)

    # TODO: Add Debian support here

    # CFLAGS, defines and libs not found
    return "", "", "", "", ""


# Test ELF-files to be generated. Don't add "test" here since it may be passed back to this file as an argument!
test_elves = [os.path.splitext(fn)[0] for fn in glob.glob("*" + TEST_SUFFIX)]

# Custom command line targets
if 'clean' in COMMAND_LINE_TARGETS:  # Clean built executables and object files
    # Replace the "clean" argument with "-c", and list all targets
    cmd = [x for x in sys.argv if x != "clean"] + ["-c"] + [MAIN_EXECUTABLE] + test_elves
    # Clean
    status, output = commands.getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)
elif 'testbuild' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "testbuild"] + test_elves
    # Build the tests
    status, output = commands.getstatusoutput(" ".join(cmd))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)
elif 'test' in COMMAND_LINE_TARGETS:  # Build and run tests
    if not test_elves:
        print("Nothing to build")
        sys.exit(0)
    # Remove the "test" argument, and list all test-executable targets
    cmd = [x for x in sys.argv if x != "test"] + test_elves
    # Build the tests
    output = subprocess.check_output(cmd)
    output = os.linesep.join([line for line in output.split(os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run the tests
    for ELF in test_elves:
        status, output = commands.getstatusoutput(os.path.join(".", ELF))
        print(output.strip())
        # Exit on error
        if status != 0:
            sys.exit(status)
    sys.exit(0)
elif 'run' in COMMAND_LINE_TARGETS:  # Build and run main
    # Remove the "run" argument, and add "main"
    cmd = [x for x in sys.argv if x != "run"] + [MAIN_EXECUTABLE]
    # Check if main.cpp exists
    if not os.path.exists(MAIN_SOURCE):
        print("Nothing to run (no " + MAIN_SOURCE + ")")
        sys.exit(0)
    # Build main
    output = subprocess.check_output(cmd)
    output = os.linesep.join([line for line in output.split(os.linesep) if not "up to date" in line]).strip()
    if output:
        print(output)
    # Run main
    status, output = commands.getstatusoutput(os.path.join(".", MAIN_EXECUTABLE))
    output = output.strip()
    if output:
        print(output)
    sys.exit(status)

# Set the number of jobs to the number of CPUs
SetOption('num_jobs', multiprocessing.cpu_count())

# Random build-order, for the possiblity of using the cache better
SetOption('random', 1)

# Create an environment
env = Environment()

# Use the latest C++ standard (C++17)
env.Append(CXXFLAGS=' -std=c++17')

# debug=1
if int(ARGUMENTS.get('debug', 0)):
    env.Append(CXXFLAGS=' -O1 -g')
else:
    env.Append(CXXFLAGS=' -O2')

# opt=1
if int(ARGUMENTS.get('opt', 0)):
    env.Append(CXXFLAGS=' -O3')

# clang=1
if int(ARGUMENTS.get('clang', 0)):
    env.Replace(CXX='clang++')

# Warnings and fail at first error
env.Append(CXXFLAGS=' -Wall -Wshadow -pedantic -Wfatal-errors')

# strict=1, even more warnings
if int(ARGUMENTS.get('strict', 0)):
    env.Append(CXXFLAGS=' -Wextra -Wconversion -Weffc++')

# sloppy=1, just try to build the damn thing
if int(ARGUMENTS.get('sloppy', 0)):
    env.Append(CXXFLAGS=' -fpermissive -w')

# Find all .cpp files that are not not *_test.cpp, not main.cpp and not test.cpp
dep_src = [fn for fn in glob.glob("*.cpp") if not fn.endswith(TEST_SUFFIX) and fn != MAIN_SOURCE and fn != "test.cpp"]

# add path to the include files
env.Append(CPPPATH=LOCAL_INCLUDE_PATHS)

# Find all included header files in ../include, then check if there are corresponding .cpp files in ../common and add them to dep_src, if there is a main source file
if os.path.exists(MAIN_SOURCE):
    includes = []
    has_new_include = True
    examined = []
    while has_new_include:
        has_new_include = False
        for INCLUDE_PATH in LOCAL_INCLUDE_PATHS:
            for filename in dep_src + [MAIN_SOURCE] + [os.path.join(INCLUDE_PATH, x) for x in includes]:
                if filename in examined:
                    continue
                examined.append(filename)
                if os.path.exists(filename):
                    new_includes = [line.split("\"")[1] for line in open(filename).read().split(
                        os.linesep)[:-1] if line.strip().startswith("#include \"")]
                else:
                    continue
                for new_include in [os.path.relpath(x) for x in new_includes]:
                    if new_include not in includes:
                        has_new_include = True
                        includes.append(new_include)
            for include in includes:
                for COMMON_PATH in LOCAL_COMMON_PATHS:
                    source_filename = os.path.join(COMMON_PATH, include.rsplit(".", 1)[0] + ".cpp")
                    if os.path.exists(source_filename):
                        if source_filename not in dep_src:
                            dep_src.append(source_filename)

# Find extra CFLAGS for the sources, if not cleaning
if not env.GetOption('clean'):
    for src_file in [MAIN_SOURCE] + dep_src:
        includes, defines, libs, linkflags, cflags = get_includes_defines_libs_linkflags_and_cflags(src_file)
        if includes:
            env.Append(CPPPATH=includes)
        if defines:
            for define in defines.split(" "):
                env.Append(CPPDEFINES=define)
        if libs:
            env.Append(LIBS=libs.split(" "))
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if cflags:
            env.Append(CPPFLAGS=cflags)

# Build main executable
main = env.Program(MAIN_EXECUTABLE, [MAIN_SOURCE] + dep_src)

# Find extra CFLAGS for the test sources, if not cleaning
if not env.GetOption('clean'):
    for ELF in test_elves:
        includes, defines, libs, linkflags, cflags = get_includes_defines_libs_linkflags_and_cflags(ELF + ".cpp")
        if includes:
            env.Append(CPPPATH=includes)
        if defines:
            for define in defines.split(" "):
                env.Append(CPPDEFINES=define)
        if libs:
            env.Append(LIBS=libs.split(" "))
        if linkflags:
            env.Append(LINKFLAGS=linkflags)
        if cflags:
            env.Append(CPPFLAGS=cflags)

## Remove non-existing includes
includes = [include for include in env['CPPPATH'] if os.path.exists(include)]
# Remove duplicate includes (in terms of pointing to the same directory)
includemap = {}
for include in includes:
    key = os.path.normpath(include)
    if key in includemap:
        # use the shortest includepath, if several are specified for the same directory
        if len(include) < len(includemap[key]):
            if len(os.path.relpath(include)) < len(include):
                includemap[key] = os.path.relpath(include)
            else:
                includemap[key] = include
    else:
        if len(os.path.relpath(include)) < len(include):
            includemap[key] = os.path.relpath(include)
        else:
            includemap[key] = include
new_includes = includemap.values()
env.Append(CPPFLAGS=" ".join(["-I" + x for x in new_includes]))
env.Replace(CPPPATH=[])
# This also work for adding includes, but SConstruct changes them to longer versions
#env.Replace(CPPPATH=new_includes)

# Set up non-default targets for all the test executables (based on *_test.cpp)
for ELF in test_elves:
    env.Program(ELF, [ELF + ".cpp"] + dep_src)

# Only main is the default target
Default(main)

# vim: ts=4 sw=4 et:
